Within the gLite WMS, upon creation
 each job is assigned a~unique, virtually non-recyclable
\emph{job identifier} (JobId) in an~URL form.
The server part of the URL designates the \emph{bookkeeping server} which
gathers and provides information on the job for its whole life.

High level view on the \LB\ architecture is shown in Fig.~\ref{fig-arch}
on page~\pageref{fig-arch}.

\LB\ tracks jobs in terms of \emph{events} (\eg\ \emph{Transfer} from a~WMS
component to another one, \emph{Run} and \emph{Done} when the jobs starts
and stops execution, \dots).
Each event type carries its specific attributes.
The entire architecture is specialized for this purpose and is job-centric\Dash
any event is assigned to a~unique Grid job.

\subsubsection{Event delivery and storage}
The events are gathered from various WMS components by the
\emph{\LB\ producer library}
and passed on to the \emph{locallogger} daemon,
running physically close to avoid
any sort of network problems.
The locallogger's task is storing the accepted event in a~local disk file.
Once it's done, confirmation is sent back and the logging library call
returns, reporting success.
Consequently, logging calls have local, virtually non-blocking semantics.

Further on, event delivery is managed by the \emph{interlogger} daemon.
It takes the events from the locallogger (or the disk files on crash recovery),
and repeatedly tries to deliver them to the destination
bookkeeping server (known from the JobId) until it succeeds finally.
Therefore the entire event delivery is highly reliable.
However, in the standard mode described so far it is asynchronous
(there is a~synchronous mode for special usage not discussed here)
there is no direct way for the caller to see whether an event has been
already delivered.
Our experience shows that the semantics is suitable in the prevailing number
of cases while being the most efficient in the erratic Grid environment.

The bookkeeping server processes the incoming events
to give a~higher level view
on the job states (\eg\ \emph{Submitted, Running, Done}),
each having an appropriate set of attributes again.
\LB\ provides a~public interface (Sect.~\ref{query-C})
to retrieve them via synchronous queries.

Further on, upon each event delivery to the \LB\ server the new computed 
job state is matched against the set of registered requests for notification.
If some of them match, special events\Dash\emph{notifications} are generated
and passed to a~modified 
\emph{notification interlogger}.
It takes over the notification from LB server, stores it into file and
periodically tries to deliver it to the address where the corresponding
notification client is listening.
If the user changes this address (IP or port) 
\LB\ server instructs the notification interlogger to change 
the destination of possible pending notifications.

\subsubsection{Queries}
\label{arch-queries}
One part of the \LB\ interface is the query API (Sect.~\ref{query-C}).
Two types of queries are supported\Dash\emph{job queries} which return
one or more jobs, including a~detailed description of their states,
and \emph{event queries} returning the raw \LB\ events.
In general, job queries are used to track normal life of jobs,
event queries are used mostly for tracing abnormal behaviour. 

Each query is formed of several conditions (\eg\ concrete jobid's,
owner of jobs, particular job state etc.).
The \LB\ library formats the conditions into a~query message, passes it to
the server, and waits for the response which is passed to the user
synchronously.

\subsubsection{Notifications}
\label{notification}
On the contrary, the notification API (Sect.~\ref{notify-C}) allows
the user to 
register for notifications. These are delivered to the listening
client asynchronously, when the particular event (a~change of job status
typically) occurs.
The main purpose of this \LB\ functionality is avoiding unnecessary load
on the \LB\ server serving many repeated queries (polling) with the same
result most of the time.

Using a~notification client (program that uses LB client
API to handle notifications) the user registers with a~\LB\ server
to receive notifications. 
She  must specify conditions under which the
notification is sent. These conditions are a~subset of the conditions
available for synchronous queries (Sect.~\ref{arch-queries}).
Currently due to implementation constraints, one
or more jobid's are required among the conditions and only
a~single occurrence of a~specific attribute is allowed. The registration is 
sent to the \LB\ server in the same way as synchronous queries,
and stored there.
In response, the server generates a~unique notification ID which is used
by the user to refer to this notification further on.
The user may
change conditions which trigger notification, prolong validity of
the registration, remove the registration from LB server,
or even change the destination of notifications, \ie\ the address where
a~client listens for notifications.

The registration is soft-state; it exists only for limited amount of time. The
validity is returned by LB server together with notification ID.

While the registration is valid, 
the user may stop the notification client and launch another, even
on a~different machine.
Notifications generated during the time when there was no client listening
for them are kept by the notification interlogger.
Once a~new listening address is announced to the
server, the pending notifications are delivered. 

