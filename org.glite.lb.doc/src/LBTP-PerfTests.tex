\section{Performance and Stress Tests}
\TODO{review, reformat, update also \url{https://meta.cesnet.cz/mediawiki/index.php/LB_and_JP_Performance_Testing}, ...}

In this section we describe tests from layers 4 (stress tests) and 5 (performance tests). 
General idea of performance and stress tests of LB components is the following:

\begin{itemize}

\item All source modifications for tests are in CVS, conditionaly compiled only
with appropriate symbol.

\item To compile LB with performance testing enabled, set environment variable
\verb'LB_PERF' to 1 prior to LB build:
\begin{verbatim}
   export LB_PERF=1
   etics-build org.glite.lb
\end{verbatim}

\item Component tests are run by shell scripts located under component
directories, these tests may require binaries from other components, though.

\item All tests use sequence of events for typical jobs (small job, big job,
small DAG, big DAG) prepared beforehand. These events are stored in files in
ULM format in CVS (see \texttt{org.glite.lb.common/examples}).
\TODO{new strategy? use real jobs...}

\item Events are generated by \verb'glite-lb-stresslog' program, which reads
ULM text of events for particular test job and logs the event sequence directly
by calling \verb'*_DoLogEvent<variant>'. The number of test jobs is
configurable. Stresslog inserts into every event timestamp when the event was
generated and sent.

\item Events are consumed by breaking normal event processing either in the
component being tested or the next component in chain, that is instrumented to
read and discard events immediately. The consumption itself is done by calling
special function which takes current time, extracts timestamp from event and
prints the difference (ie. the event processing time)\footnote{the only
exception is test of the logging library itself}. These "break points" are
chosen to measure throughput of the various component parts and to identify
possible bottlenecks within the components.

\item Test jobs are preregistered within the LB if the test includes
bookkeeping server and/or proxy by the test script program and their id's are
stored in separate file to enable re-use by other load-generating tools (status
queries, for example).

\item Test results:
   \begin{itemize}
   \item Some numbers must be reported by component themselves, not by
      the event generator (due to the asynchronous LB nature). The
      test script collects those numbers and presents them as the test
      result at the end of testing.

    \item After completion test scripts print the table described for the
      respective tests filled in with measured values (ie. the table
      is not filled in manually by human tester).
 
    \item Measure event throughput bu
    \[ \mbox{event\_throughput} = \frac{1}{\mbox{time\_delivered} - \mbox{time\_arrived}} \]
\TODO{measure job throughput for event patterns of typical jobs or deduce
job throughput from throughput of selected types of events?}

    \item Publish the results on the web.
\TODO{ETICS test? \url{https://meta.cesnet.cz/mediawiki/index.php/LB_and_JP_Performance_Testing}? etc.}
    \end{itemize}
% vztahuje se k cemu?
% * only if next event is sent after previous was delivered
%
\end{itemize}

In the following subsections we describe performance and stress tests for
individual LB compoments.  They include both tests of the isolated components
on one node (may require binaries from other components to produce/consume
events) as well as tests of LB components among more nodes.


%--------------------
\subsection{Logging library test}
%--------------------

\begin{verbatim}
* component:  
     org.glite.lb.client

* binaries required: 
     logevent_libtest

* test shell script:
     perftest_loglib

* input required:
     - events

* test description:
     - measures time required to format given events into ULM. Events
       are read from file, parsed into components, timestamped and
       produced. 

     - events produced:
         - by calling logging function edg_wll_LogEvent*()

     - events consumed:
         - discarded by logging function instead of sending via
           appropriate protocol (LogEventMaster)

* results:

  job type (size)    throughput (100k jobs)
  -----------------------------------------
   small job
   big job
   small DAG
   big DAG

\end{verbatim}


% ----------------
\subsection{Locallogger test}
% ----------------

\begin{verbatim}
* component:
     org.glite.lb.logger

* binaries required:
     stresslog
     glite_lb_logd_perf
     glite_lb_logd_perf_nofile
	- does not store events in file
     glite_lb_interlogd_perf_empty
	- consumes immediately after reading event

* test shell script:
     perftest_logd

* input required:
     - client and host certificates
     - events

* test description:
      - measures time required for event to be sent from client to
        local logger and processed by locallogger. Localloger is
        either instructed (by option) or instrumented to skip some
        parts of event processing:
	      a) no parse, no file, no ipc
		    glite_lb_logd_perf_nofile --noParse --noIPC
	      b) no file, no ipc
		    glite_lb_logd_perf_nofile --noIPC
	      c) no ipc
		    glite_lb_logd_perf --noIPC
	      d) normal operation
		    glite_lb_logd_perf

         no parse - LL does not parse events 
         no file  - LL does not store events into files
         no ipc   - LL does not send events through socket to IL

      - events produced:
           - stresslog sends events to logd using client->logd
             protocol (*_DoLogEvent())

      - events consumed:
           i) after storing into files
          ii) by "empty" IL
        
* results:



i) events stored in files

   throughput:     small    big    small    big 
                   job      job    DAG      DAG 
   -------------------------------------------------
   a)
   b)
   c)
   d)

ii) events sent to IL

   throughput:     small    big    small    big 
                   job      job    DAG      DAG 
   -------------------------------------------------
   a)
   b)
   c)
   d)


\end{verbatim}

% ----------------
\subsection{Interlogger test}
% ----------------

\begin{verbatim}
* component:
     org.glite.lb.logger

* binaries required:
     stresslog
     glite_lb_interlogd_perf
     glite_lb_interlogd_perf_noparse
        - does not parse events, server address is hardcoded
     glite_lb_interlogd_perf_nosync
	- does not call event_store_sync()
     glite_lb_interlogd_perf_norecover
	- recovery thread disabled
     glite_lb_interlogd_perf_nosend
	- events are consumed instead of sending
     glite_lb_interlogd_perf_lazy
	- lazy closing connection to bkserver
     glite_lb_bkserverd_perf_empty
	- consumes event immediately after receiving

* test shell script:
     perftest_interlogd

* input required:
     - host certificate
     - events

* test description:
     - measures time the event travels through interlogger.
       Interlogger is instrumented to skip some parts of eventh
       processing for particular test, specifically tests include
       these variants: 
	      a) disabled event parsing. The server address
                 (eg. jobid) is hardcoded.
	      b) disabled event synchronization from files
	      c) disabled recovery thread
	      d) lazy bkserver connection close
	      e) normal operation

     - events produced:
           1) stresslog sends events to interlogger using the unix
              domain socket and logd->interlogger protocol, events are
              stored in files (stresslog behaves like logd)
 TODO: pro toto neni funkce v producerske knihovne
           2) interlogger reads events from event files created by
              stresslog (by recovery thread)
           3) stresslog stores events to files and every n-th
              (optional argument) is sent also through the unix socket

     - events consumed:
           i) discarded instead of being sent
          ii) by "empty" bkserver

* results:


i) events discarded
1) events received on socket
(options 2 and 3 are not tested)

   throughput:     small    big    small    big 
                   job      job    DAG      DAG 
   -------------------------------------------------
   a)
   b)
   c)
   e)


ii) events sent to empty bkserver 
1) events received on socket

   throughput:     small    big    small    big 
                   job      job    DAG      DAG 
   -------------------------------------------------
   a)
   b)
   c)
   d)
   e)


2) events recovered from files

   throughput:     small    big    small    big 
                   job      job    DAG      DAG 
   -------------------------------------------------
   d)
   e)


3) events synced from files, every 10th event sent on socket

   throughput:     small    big    small    big 
                   job      job    DAG      DAG 
   -------------------------------------------------
   a)
   b)
   c)
   d)
   e)

\end{verbatim}

% ------------
\subsection{LBProxy test}
% ------------

\begin{verbatim}
* component:
     org.glite.lb.proxy

* binaries required:
     stresslog
     glite_lb_proxy_perf_noparse
	- consumes events before parsing
     glite_lb_proxy_perf_nostore
        - consumes events before storing into database
     glite_lb_proxy_perf_nostate
	- consumes events before computing job status
     glite_lb_proxy_perf_nosend
	- consumes events before sending to interlogger
     glite_lb_interlogd_perf_empty
	- consumes immediately after reading event

* test shell script:
     perftest_proxy

* input required:
     - events

* test description:
     - measures time required for processing event by LB proxy. Test
       is performed with (a)) and without (b)) checking for duplicit
       events. 

     - events produced:
	   - stresslog sends events using the IL protokol on local
	     socket (using DoLogEventProxy())

     - events consumed:
	    i) before parsing
	   ii) before storing into database
	  iii) after storing into database
	   iv) after job status computation
	    v) normal operation

 


* results:

a) with duplicity check:

   throughput:     small    big    small    big 
                   job      job    DAG      DAG 
   -------------------------------------------------
     i)
    ii)
   iii)
    iv)
     v)


b) without duplicity check:

   throughput:     small    big    small    big 
                   job      job    DAG      DAG 
   -------------------------------------------------
     i)
    ii)
   iii)
    iv)
     v)
\end{verbatim}

%--------------
\subsection{LB server test}
% --------------


\begin{verbatim}
* component:
     org.glite.lb.server

* binaries required:
     stresslog
     glite_lb_server_perf_noparse
	- consumes events before parsing
     glite_lb_server_perf_nostore
        - consumes events before storing into database
     glite_lb_server_perf_nostate
	- consumes events before computing job status

* test shell script:
     perftest_server

* input required:
     - host certificates
     - events

* test description:
     - measures time required for processing event by LB server. Test
       is performed with (a)) and without (b)) checking for duplicit
       events. 

     - events produced:
	   - stresslog sends events using the IL protokol (using DoLogEventDirect())

     - events consumed:
	    i) before parsing
	   ii) before storing into database
	  iii) after storing into database
	   iv) normal operation

* results:

a) with duplicity check:

   throughput:     small    big    small    big 
                   job      job    DAG      DAG 
   -------------------------------------------------
     i)
    ii)
   iii)
    iv)


b) without duplicity check:

   throughput:     small    big    small    big 
                   job      job    DAG      DAG 
   -------------------------------------------------
     i)
    ii)
   iii)
    iv)

\end{verbatim}

% ---------------------
\subsection{Job registration test}
% ---------------------

\begin{verbatim}
* component:
     org.glite.lb.server
     org.glite.lb.proxy

* binaries required:
     stressreg
        - generates registration events
     glite_lb_bkserverd
     glite_lb_proxy
     glite_lb_bkserverd_perf_empty
     glite_lb_proxy_perf_empty
     
* test shell script:
     perftest_jobreg

* input required:
     - host & user certificates

* test description:
     - measures time required to register given number of jobs (time
       to process registration event). The registration event is
       synchronous in principle, so it is possible to get results just
       from the client (stressreg). Test variants include:
	    a) current implementation
	    b) implementation of connection pool at the client
	    c) parallel communication with server and proxy
       
       
     - events produced:
           - stressreg sends registration events by calling
	     edg_wll_RegisterJob*()

     - events consumed:
           i) normally processed by server & proxy
	  ii) server replies immediate success
         iii) proxy replies immediate success

* results:

a) current implementation

   throughput:     one       DAG           DAG             DAG
                   job   (1000 nodes)  (5000 nodes)   (10000 nodes)
   -----------------------------------------------------------------
     i)
    ii)
   iii)


b) connection pool

   throughput:     one       DAG           DAG             DAG
                   job   (1000 nodes)  (5000 nodes)   (10000 nodes)
   -----------------------------------------------------------------
     i)
    ii)
   iii)


c) parallel communication

   throughput:     one       DAG           DAG             DAG
                   job   (1000 nodes)  (5000 nodes)   (10000 nodes)
   -----------------------------------------------------------------
     i)


\end{verbatim}

% ---------------------
\subsection{"Real world" tests}
% ---------------------

Aim of these tests is to simulate real environment of the LB operation as
closely as possible. We simulate the environment on WMS node as this is the
most performance critical point. Events are sent through proxy and interlogger
on one machine (WMS node) to the server on another machine (LB node), we also
create some background noise by simultaneously polling the server and/or proxy
for job status by several clients in parallel.

