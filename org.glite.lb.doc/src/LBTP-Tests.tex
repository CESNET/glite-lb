\section{Test Cases}

In this section we describe tests from layers 2 (service functionality tests)
and 3 (system tests). 

\TODO{completely review}


\subsection{Event delivery}

% locallogger
% bez dalsich demonu, registrovat job, vrati EAGAIN, objevi se fajly
\subsubsection{Standalone locallogger -- job registration}
\label{reg}
\req\ running \path{glite-lb-logd} on the test node, don't start either
\path{glite-lb-interlogd} or \path{glite-lb-bkserverd}

\how\ call \code{edg\_wll\_RegisterJob}. Jobid's should preferably point
to a~remote \LB\ server.

\result\ The API call returns EAGAIN, but locallogger creates an event file
in its storage.
The file should contain single line RegJob event.

\begin{hints}
\path{glite-lb-regjob} example can be used. It generates a~unique jobid,
prints it and calls \LB\ API appropriately.
\end{hints}

% async -- prida do fajlu, OK
% logevent
\subsubsection{Standalone locallogger -- log event}
\label{log}
\req\ running \path{glite-lb-logd} only, files generated in test~\ref{reg}.

\how\ call \code{edg\_wll\_Log*} for various event types in a~sequence
resebmling real \LB\ usage, using the same jobid's as in test~\ref{reg}

\result\ API calls return 0, events are added one per line to the locallogger files

\begin{hints}
\path{glite-lb-logev} client program can be used.

\path{glite-lb-*.sh} examples may be adapted to produce reasonable seqences
of events.
\end{hints}

\subsubsection{Interlogger recovery}
\label{recover}
% recover interloggeru
% il & server (remote)
% spustit, protlaci soubory na server, soubory zmizi, lze se dotazat na stav
\req\ running \path{glite-lb-bkserverd} on the machine and port where 
jobid's from \ref{reg} point to; files generated in~\ref{log}.

\how\ Make a~copy of the files created in~\ref{log}, then start
\path{glite-lb-interlogd}. After approx. 10s check the jobs
with \code{edg\_wll\_JobLog} call. 

\result \code{edg\_wll\_JobLog} should return the same events that were
contained in the locallogger files. The files should be removed by 
interlogger after approx. 1 min.

\begin{hints}
\path{glite-lb-joblog} example outputs the events in (almost) the same
format as the locallogger files.
\end{hints}

% event delivery
% poslat .sh, job log vrati to, co bylo ve fajlech
\subsubsection{Normal event delivery}
\label{normal}
\req\ all \LB\ daemons running (\path{glite-lb-logd}, \path{glite-lb-interlogd},
\path{glite-lb-bkserverd}

\how\
\begin{enumerate}

\item Register jobs with \code{edg\_wll\_RegsterJob} 
\item Log reasonable sequences of events with \code{edg\_wll\_Log*}.
\item Check with \code{edg\_wll\_JobLog}
that the events got delivered afterwards (approx. 10s).
\end{enumerate}

\result\ API calls should return 0. The same events that were logged must be returned.

\begin{hints}
\path{glite-lb-*.sh} scripts produce reasonable seqences of events, including
the job initial registration.

There is approx. 1min time window in which the locallogger files exist.
They can be grabbed and used for comparing the events as in~\ref{recover}.

\end{hints}

\subsection{Job state computation}

% normal event delivery & job state machine
% .sh, dotaz na stav
\subsubsection{Normal job states}
\label{state}
\req\ \path{glite-lb-bkserverd} running, events from \ref{normal} logged.

\how\ Check state of the jobs with \code{edg\_wll\_JobStatus}.

\result\ The API call should return 0, the jobs should be in the expected
states. Thorough tests may also cross check the values supplied in the
events (e.g. destination computing element) wrt. the values reported in the job states.

\begin{hints}
\path{glite-lb-*.sh} scripts produce sequences of events resultning
in the job state same as the `*' part of the script name.
\end{hints}

\subsubsection{DAG job states}
\TODO{}
% specialni stav DAGu, histogram potomku

\subsection{LB proxy}
\req\ running \path{glite-lb-proxy}, \path{glite-lb-interlogd} and
\path{glite-lb-bkserverd}

\how\ Register jobs with \code{edg\_wll\_RegisterJobProxy}, log events
using \code{edg\_wll\_LogEventProxy} and check the job states against
both lbproxy (using \code{edg\_wll\_JobStatusProxy}) and bkserver
(using \code{edg\_wll\_JobStatus}).

\result\ A new job state should be available immediately at the
lbproxy and probably with a small delay also at the bkserver.

\begin{hints}
There is already a script \path{test.sh} in
\path{org.glite.lb.proxy/examples} that can be used together with
above mentioned scripts \path{glite-lb-*.sh} (they are called from
\path{test.sh}) to test all this.
\end{hints}

\subsection{WS interface}
\req\ \path{glite-lb-bkserverd} running, events from \ref{normal} logged

\how\ retrieve both events and job states with the \LB\ WS interface
(operations \code{JobStatus}, \code{QueryEvents}).

\result\ the returened data should match those returned by the legacy
API calls.

\begin{hints}
Examples \path{org.glite.lb.server/examples/ws\_*.c} convert the WS
responses back to the legacy \LB\ data structures and print them in
the same form as e.g. \path{glite-lb-jobstat}.
\end{hints}

\subsection{Notifications}

% notifikace 
% regjob, reg notifikace na vsechno, poslat udalosti, hlidat notif
\subsubsection{Single job, any state change}
\label{notif1}
\req\ All \LB\ services running

\how
\begin{enumerate}
\item Register a job. 
\item Start a~notification client (preferably on another machine),
register with \code{edg\_wll\_NotifNew} for any state changes of the job, 
and repeatedly invoke \code{edg\_wll\_NotifReceive}.
\item One by one send events triggering job state change. 
\end{enumerate}

\result\ All the events should trigger notification reported by the running
notification client.

\begin{hints}
\path{glite-lb-notify} example can be used with its \path{test} command.
\end{hints}

\subsubsection{Additional notification criteria}
\label{notif-complex}
\req\ All \LB\ services running

\how\ Like~\ref{notif1} but include additional criteria,
e.g. job is scheduled for a~specific destination.

\result\ Only notifications matching the criteria should be delivered.

% rozsireni dotazu o dalsi job
\subsubsection{Include another job}
\label{notif2}
\req\ All \LB\ services running, notification from \ref{notif1} still active

\how\ 
\begin{enumerate}
\item Register another job.
\item Augment the notification registration with the new jobid using
\code{edg\_wll\_NotifChange}.
\item Start notification client, bind to the registration with
\code{edg\_wll\_NotifBind}.
\item Send events for the new job.
\end{enumerate}

\result\ Notifications should be received by the client.

\begin{hints}
Commands \path{change} and \path{receive} of \path{glite-lb-notify}
can be used.
\end{hints}

% notifikace -- zmena adresy/portu
% pak poslat udalost, musi dojit
% uz je v predchozim implicitne

\subsubsection{Delayed delivery}
% notifikace -- zpozdene doruceni
% registrovat, odpojit, poslat udalosti, pripojit se

\req\ All \LB\ services running

\how\ 
\begin{enumerate}
\item Register another job.
\item Register a~notification as in~\ref{notif1} but terminate the client
immediately.
\item Log events for the job.
\item Restart the client, binding to the notification and call
\code{edg\_wll\_NotifReceive} repeatedly.
\end{enumerate}

\result\ Delayed notifications should be received by the client almost
immediately.

\subsection{Server purge}

\textbf{WARNING: This test is destructive, it destroys ALL data in an
existing \LB\ database.} 

The test is fairly complex but it does not make too much sense to split it
artificially.

\req\ All \LB services running, preferably a~dedicated server for this test.

\how
\begin{enumerate}
\item Purge all data on the server with \path{glite-lb-purge}
\item Log two sets of jobs, separated with delay of at least 60s so
that the sets can be distinguished from each other.
\item \label{purgel}
Using \code{edg\_wll\_JobLog} retrieve events of all the jobs
\item \label{purge1}
Purge the first set of jobs (by specifying appropriate timestamp),
letting the server dump the purged events.
\item \label{purge2} Purge the other set of jobs, also dumping the events.
\item \label{purge3} Run purge once more.
\end{enumerate}

\result\ The data dumped in steps \ref{purge1}, \ref{purge2} should be the
same as retrieved in~\ref{purgel}. The final purge invocation should
do nothing (i.e. nothing was left in the database).

% test_purge
\begin{hints}
The example \path{glite-lb-test\_purge} does exactly this sequence of steps,
including the checks.
\end{hints}
