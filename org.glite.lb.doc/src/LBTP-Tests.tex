% System tests

\section{System functionality tests}
\label{s:functionality}
\TODO{vsichni: znovu cele projit}

\subsection{Event delivery}



\subsubsection{Normal event delivery}
\label{normal}
% event delivery
% poslat .sh, job log vrati to, co bylo ve fajlech

\req\ all \LB\ daemons running (\path{glite-lb-logd}, \path{glite-lb-interlogd},
\path{glite-lb-bkserverd})

\what\ 
\begin{enumerate}
\item Register jobs with \code{edg\_wll\_RegsterJob} 
\item Log reasonable sequences of events with \code{edg\_wll\_Log*}, both through logger and/or proxy
\item Check with \code{edg\_wll\_JobLog} that the events got delivered afterwards (approx. 10s).
\end{enumerate}

\how\ \ctblb{lb-test-normal-event-delivery.sh}
% org.glite.testsuites.ctb/LB/lb-l2.sh now does the following:
% - array_job_reg: registeres $JOBS_ARRAY_SIZE jobs
% - logEvents: logs events by glite-lb-$state.sh example scripts
% - logTags: logs user tags
% - testLB: calls glite-lb-job_log for all jobs
% - testLB2: calls glite-lb-job_status for all jobs
%
% What needs to be done:
% - rename the script, tidy it
% - create some meaningful sequence of events for logEvents

\result\ All sub tests (API calls) should return 0. The same events that were logged must be returned.

\begin{hints}
\path{glite-lb-*.sh} scripts produce reasonable seqences of events, including
the job initial registration.

There is approx. 1 min time window in which the locallogger files exist.
They can be grabbed and used for comparing the events later in~\ref{recover}.
\end{hints}



\subsubsection{Job registration only}
\label{reg}
\req\ running \path{glite-lb-bkserverd}

\what\ call \code{edg\_wll\_RegisterJob}. Jobid's should preferably point
to a~remote \LB\ server.

\how\ \ctblb{lb-test-job-registration.sh}

\result\ All sub tests (API calls) return 0.

\begin{hints}
\path{glite-lb-regjob} example can be used. It generates a~unique jobid,
prints it and calls \LB\ API appropriately.
\end{hints}



\subsubsection{Standalone locallogger -- log event}
\label{log}
% async -- prida do fajlu, OK
% logevent

\req\ running \path{glite-lb-logd} only, jobs registered in test~\ref{reg}.

\what\ call \code{edg\_wll\_Log*} for various event types in a~sequence
resebmling real \LB\ usage, using the same jobid's as in test~\ref{reg}

\how\ \ctblb{lb-test-logevent.sh}

\result\ All sub tests (API calls) return 0, events are added one per line to the locallogger files.

\begin{hints}
\path{glite-lb-logevent} client program can be used.

\TODO{\path{glite-lb-*.sh} examples may be adapted to produce reasonable seqences
of events.}
\end{hints}



\subsubsection{Interlogger recovery}
\label{recover}
% recover interloggeru
% il & server (remote)
% spustit, protlaci soubory na server, soubory zmizi, lze se dotazat na stav

\req\ running \path{glite-lb-bkserverd} on the machine and port where
jobid's from \ref{reg} point to; files generated in~\ref{log};
\path{glite-lb-interlogd} is stopped.

\what\ Make a~copy of the files created in~\ref{log}, then start
\path{glite-lb-interlogd}. After approx. 10s check the jobs
with \code{edg\_wll\_JobLog} call.

\how\ \ctblb{lb-l2ILR.sh}

\result \code{edg\_wll\_JobLog} should return the same events that were
contained in the locallogger files. The files should be removed by
interlogger after approx. 1 min.

\begin{hints}
\path{glite-lb-joblog} example outputs the events in (almost) the same
format as the locallogger files.
\end{hints}




\subsection{Job state computation}

\subsubsection{Normal job states}
\label{state}
% normal event delivery & job state machine
% .sh, dotaz na stav

\req\ \path{glite-lb-bkserverd} running, events from \ref{normal} logged.

\what\ Check state of the jobs with \code{edg\_wll\_JobStatus}. Check all possible job states 
(if necessary, log relevant events). Query both server and/or proxy.

\result\ The API call should return 0, the jobs should be in the expected
states. Thorough tests may also cross check the values supplied in the
events (e.g. destination computing element) wrt. the values reported in the job states.

\begin{hints}
\path{glite-lb-*.sh} scripts produce sequences of events resultning
in the job state same as the `*' part of the script name.
\end{hints}



\subsubsection{Non-simple job states}
\TODO{dags, collections, their states and states (and histogram) of their children/subjobs, ...}



\subsection{LB server and proxy combined test}
\TODO{mulac: mizeni jobu z proxy, alias kombinovany test na server-proxy}

\req\ running \path{glite-lb-proxy}, \path{glite-lb-interlogd} and
\path{glite-lb-bkserverd}

\what\ Register jobs with \code{edg\_wll\_RegisterJobProxy}, log events
using \code{edg\_wll\_LogEventProxy} and check the job states against
both lbproxy (using \code{edg\_wll\_JobStatusProxy}) and bkserver
(using \code{edg\_wll\_JobStatus}). Pay special attention to job reaching final 
job status and to the automatic purge from proxy - check the timeouts.

\result\ A new job state should be available immediately at the
lbproxy and probably with a small delay also at the bkserver. Jobs that reach the final job state
are really purged from the proxy in given timeout.

\begin{hints}
There is already a script \path{test.sh} in
\path{org.glite.lb.proxy/examples} that can be used together with
above mentioned scripts \path{glite-lb-*.sh} (they are called from
\path{test.sh}) to test all this.
\end{hints}



\subsection{WS interface}
\TODO{fila: ws example + html example}
\req\ \path{glite-lb-bkserverd} running, events from \ref{normal} logged

\how\ retrieve both events and job states with the \LB\ WS interface
(operations \code{JobStatus}, \code{QueryEvents}).

\result\ the returened data should match those returned by the legacy
API calls.

\begin{hints}
Examples \path{org.glite.lb.server/examples/ws\_*.c} convert the WS
responses back to the legacy \LB\ data structures and print them in
the same form as e.g. \path{glite-lb-jobstat}.
\end{hints}



\subsection{Change ACL}
\TODO{kouril: pozdeji - s novym auth. schematem. dopsat TODO jak}




\subsection{Notifications}
\TODO{ruda: revize, doplnit nove optiony}
% notifikace
% regjob, reg notifikace na vsechno, poslat udalosti, hlidat notif



\subsubsection{Single job, any state change}
\label{notif1}
\req\ All \LB\ services running

\what
\begin{enumerate}
\item Register a job.
\item Start a~notification client (preferably on another machine),
register with \code{edg\_wll\_NotifNew} for any state changes of the job,
and repeatedly invoke \code{edg\_wll\_NotifReceive}.
\item One by one send events triggering job state change.
\end{enumerate}

\result\ All the events should trigger notification reported by the running
notification client.

\begin{hints}
\path{glite-lb-notify} example can be used with its \path{test} command.
\end{hints}



\subsubsection{Additional notification criteria}
\label{notif-complex}
\req\ All \LB\ services running

\how\ Like~\ref{notif1} but include additional criteria,
e.g. job is scheduled for a~specific destination.

\result\ Only notifications matching the criteria should be delivered.

% rozsireni dotazu o dalsi job



\subsubsection{Include another job}
\label{notif2}
\req\ All \LB\ services running, notification from \ref{notif1} still active

\how\
\begin{enumerate}
\item Register another job.
\item Augment the notification registration with the new jobid using
\code{edg\_wll\_NotifChange}.
\item Start notification client, bind to the registration with
\code{edg\_wll\_NotifBind}.
\item Send events for the new job.
\end{enumerate}

\result\ Notifications should be received by the client.

\begin{hints}
Commands \path{change} and \path{receive} of \path{glite-lb-notify}
can be used.
\end{hints}

% notifikace -- zmena adresy/portu
% pak poslat udalost, musi dojit
% uz je v predchozim implicitne



\subsubsection{Delayed delivery}
% notifikace -- zpozdene doruceni
% registrovat, odpojit, poslat udalosti, pripojit se

\req\ All \LB\ services running

\how\
\begin{enumerate}
\item Register another job.
\item Register a~notification as in~\ref{notif1} but terminate the client
immediately.
\item Log events for the job.
\item Restart the client, binding to the notification and call
\code{edg\_wll\_NotifReceive} repeatedly.
\end{enumerate}

\result\ Delayed notifications should be received by the client almost
immediately.




\subsection{Server purge}
\TODO{ljocha, valtri: ozivit skript i text}

\textbf{WARNING: This test is destructive, it destroys ALL data in an
existing \LB\ database.}

The test is fairly complex but it does not make too much sense to split it
artificially.

\req\ All \LB services running, preferably a~dedicated server for this test.

\how
\begin{enumerate}
\item Purge all data on the server with \path{glite-lb-purge}
\item Log two sets of jobs, separated with delay of at least 60s so
that the sets can be distinguished from each other.
\item \label{purgel}
Using \code{edg\_wll\_JobLog} retrieve events of all the jobs
\item \label{purge1}
Purge the first set of jobs (by specifying appropriate timestamp),
letting the server dump the purged events.
\item \label{purge2} Purge the other set of jobs, also dumping the events.
\item \label{purge3} Run purge once more.
\end{enumerate}

\result\ The data dumped in steps \ref{purge1}, \ref{purge2} should be the
same as retrieved in~\ref{purgel}. The final purge invocation should
do nothing (i.e. nothing was left in the database).

% test_purge
\begin{hints}
The example \path{glite-lb-test\_purge} does exactly this sequence of steps,
including the checks.
\end{hints}
