% -*- mode: latex -*-

\section{\LB\ Notification API}
\label{s:Notification-API}

\TODO{sitera: prepsat ve stejnem duchu jako predchozi kapitoly, zminit novinky v \LBnew}

The \LB\ notification API is another kind of \LB\ consumer API which
provides streaming publish/subscribe model instead of query/response
model. It is designed to provide the same information and use the same
query conditions encoding as the consumer API described in
sec.~\ref{s:Consumer-API}

Basic usage of the \LB\ notification API is described in the \LB
user's guide (\cite{lbug}) in section ``Tools'' as there is described
a tool called \verb'glite-lb-notify' which is a command line interface
wrapper around the \LB\ notification API. Its source code can also
serve as a complete exaple of the \LB\ notification API usage.

The \LB\ notification API have currently only C language binding.

\subsection{Header files}
\begin{table}[h]
\begin{tabularx}{\textwidth}{>{\tt}lX}
glite/lb/notification.h & Prototypes for all notification API functions. \\
\end{tabularx}
\end{table}

\subsection{Call semantics}
The API have two main parts: notification subscription management and
receiving data. Each subscription (registration of notification) have
its unique identifier called \emph{Notification ID} represented by
type \verb'edg_wll_NotifId'. This ID is returned to the caller when
creating a new notification and it is used by receiver to get data
from the notification.

The API uses \verb'EDG_WLL_NOTIF_SERVER' context parameter to set the
source server (\LB server name and port). 

The typical notification workflow consist of 3 tasks:
\begin{itemize}
 \item Create a new notification registration based on given conditions.
 \item Refresh the registration. Each notification registration is
  soft-state registration and must be regullarly refreshed by the
  owner.
 \item Receiving the data from notification. The \LB infrastructure
  provides data queuing and garantied delivery (while the registration
  is valid).
\end{itemize}

For complete reference of all API funcions please see the header
file. The next sessions briefly describe main facts about API
funcions.

\subsection{Notification subscription and management}
To create a new notification registration the same encoding of
conditions as for the \LB query/response API is used
(sec.~\ref{s:queryrec}). In version 1.x there is a restriction that at
least one particular JobId must be defined. In \LB 2.0 you cat make a
registration based on other attributes without referencing a
particular JobId (you can select owner, VO, network server).

A new notification is created using \verb'edg_wll_NotifNew' call. The
notification validity parameter is intended to set the refresh period,
not the lifetime of the notification itself. The owner of notification
must periodically call \verb'edg_wll_NotifRefresh' to ensure validity
of the notification.

If user does not want to receive notifications any more,
\verb'edg_wll_NotifDrop' call removes the registration for
notifications from \LB server.

It is possible to change existing notification (its conditions) by
\verb'edg_wll_NotifChange' call.

\subsection{Receive data}
To receive data from a notificaton the API provides
\verb'edg_wll_NotifReceive' call. It returns first incoming
notification if at least one is available or waits a specified timeout. You can
also set the timeout to zero if you want to poll.

If the user wants to start receiving the notifications from different machine
than where the registration was done, it is possible but the
\verb'edg_wll_NotifBind' call must be used. 

\TODO{Reusing of socket}

\TODO{Normal usage of edg\_wll\_NotifCloseFd? Shoul be used?}

\subsection{Registering and receiving notification example}

The following example registers on \LB\ server to receive notifications triggered by events belonging to job with \verb'jobid' and waits for notification until \verb'timeout'.
The code assumes the user to prepare a~reasonable value in \verb'jobid'
(\ie\ identifying an existing job).

%The glite-lb-bkserverd and glite-lb-notif-interlogd daemons have to be running. The first one user registers to, the second one delivers notifications to the example program (as described in \ref{notification}).

\begin{verbatim}
  #include <time.h>
  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>
  #include <unistd.h>

  #include "glite/lb/context.h"
  #include "glite/lb/lb_gss.h"
  #include "glite/lb/notification.h"

  /* jobid magically appears here */
  char                    *jobid;

  edg_wll_Context         ctx;
  edg_wll_QueryRec        **conditions;
  edg_wll_NotifId         notif_id = NULL, recv_notif_id = NULL;
  edg_wlc_JobId           my_jobId = NULL;
  edg_wll_JobStat         stat;
  time_t                  valid;
  struct timeval          timeout = {220, 0};
  ...

  edg_wll_InitContext(&ctx);

  memset(&stat, 0, sizeof(stat));

  conditions = (edg_wll_QueryRec **)calloc(2,sizeof(edg_wll_QueryRec *));
  conditions[0] = (edg_wll_QueryRec *)calloc(2,sizeof(edg_wll_QueryRec));

  edg_wlc_JobIdParse(jobid, &my_jobId);

  conditions[0][0].attr = EDG_WLL_QUERY_ATTR_JOBID;
  conditions[0][0].op = EDG_WLL_QUERY_OP_EQUAL;
  conditions[0][0].value.j = my_jobId;

  /* register notification on BK server */
  if (edg_wll_NotifNew(ctx, conditions, -1, NULL, &notif_id, &validity))
    goto error;

  /* the ID string my be used to receive notifications */
  /* from another computer later on                    */
  printf("notification ID: %s\n", edg_wll_NotifIdUnparse(notif_id));

  if (edg_wll_NotifReceive(ctx, -1, &timeout, &status, &recv_notif_id))
    /* timeout or error */
    goto error;
  else {
    /* notification arrived */
    /* check recv_notif_id if you have registered more notifications */
    /* to know which one you received. If you have just this one     */
    /* do not bother.                                                */

    printf("Status of my job is: %s\n", edg_wll_StatToString(stat.state));
    edg_wll_FreeStatus(&stat);
    edg_wll_NotifIdFree(recv_notif_id);
  }

  /* Release registration on BK server. Don't do this if notif_id is reused. */
  edg_wll_NotifDrop(ctx, notif_id);

  edg_wll_NotifIdFree(notif_id);
  edg_wll_NotifCloseFd(ctx);
	
  ...

error:
	/* clean-up */
  ...

\end{verbatim}

First of all the context is initialised. During this procedure user's credentials are loaded. %(see \ref{cmdln_interface} for information on environmental variables pointing to user's X509 credentials).

Then conditions under which notifications are sent are set. In this example, user is notified every time when event with given jobId is logged to \LB\ server. For more complicated conditions, please, consider the conditions limitations mentioned in \cite{lbug}.

Afterwards, a new registration is created and a unique notification ID is
returned.
Notifications are recieved with the \verb'edg_wll_NotifReceive' call.
If no notification is ready for
delivery, the call waits until some notification arrival or timeout.


