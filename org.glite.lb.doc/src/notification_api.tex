\section{\LB\ Notification API}

The purpose of this section is demonstrating the usage of the \LB\ notification API. Two examples of basic API usage are given.


\subsection{Registering and receiving notification}

The following example registers on \LB\ server to receive notifications triggered by events belonging to job with \verb'jobid' and waits for notification until \verb'timeout'. 
The code assumes the user to prepare a~reasonable value in \verb'jobid'
(\ie\ identifying an existing job).

%The glite-lb-bkserverd and glite-lb-notif-interlogd daemons have to be running. The first one user registers to, the second one delivers notifications to the example program (as described in \ref{notification}).

\begin{verbatim}
  #include <time.h>
  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>
  #include <unistd.h>

  #include "glite/lb/context.h"
  #include "glite/lb/lb_gss.h"
  #include "glite/lb/notification.h"

  /* jobid magically appears here */
  char                    *jobid;

  edg_wll_Context         ctx;
  edg_wll_QueryRec        **conditions;
  edg_wll_NotifId         notif_id = NULL, recv_notif_id = NULL;
  edg_wlc_JobId           my_jobId = NULL;
  edg_wll_JobStat         stat;
  time_t                  valid;
  struct timeval          timeout = {220, 0};
  ...

  edg_wll_InitContext(&ctx);

  memset(&stat, 0, sizeof(stat));

  conditions = (edg_wll_QueryRec **)calloc(2,sizeof(edg_wll_QueryRec *));
  conditions[0] = (edg_wll_QueryRec *)calloc(2,sizeof(edg_wll_QueryRec));

  edg_wlc_JobIdParse(jobid, &my_jobId);

  conditions[0][0].attr = EDG_WLL_QUERY_ATTR_JOBID;
  conditions[0][0].op = EDG_WLL_QUERY_OP_EQUAL;
  conditions[0][0].value.j = my_jobId;

  /* register notification on BK server */
  if (edg_wll_NotifNew(ctx, conditions, -1, NULL, &notif_id, &validity))
    goto error;

  /* the ID string my be used to receive notifications */
  /* from another computer later on                    */
  printf("notification ID: %s\n", edg_wll_NotifIdUnparse(notif_id));

  if (edg_wll_NotifReceive(ctx, -1, &timeout, &status, &recv_notif_id))
    /* timeout or error */
    goto error;
  else {
    /* notification arrived */
    /* check recv_notif_id if you have registered more notifications */
    /* to know which one you received. If you have just this one     */
    /* do not bother.                                                */

    printf("Status of my job is: %s\n", edg_wll_StatToString(stat.state));
    edg_wll_FreeStatus(&stat);
    edg_wll_NotifIdFree(recv_notif_id);
  }
 
  /* Release registration on BK server. Don't do this if notif_id is reused. */
  edg_wll_NotifDrop(ctx, notif_id);

  edg_wll_NotifIdFree(notif_id);
  edg_wll_NotifCloseFd(ctx);
	
  ...

error:
	/* clean-up */
  ...

\end{verbatim}

First of all the context is initialised. During this procedure user's credentials are loaded. %(see \ref{cmdln_interface} for information on environmental variables pointing to user's X509 credentials). 

Then conditions under which notifications are sent are set. In this example, user is notified every time when event with given jobId is logged to \LB\ server. For more complicated conditions, please, consider the conditions limitations mentioned in \ref{notification}.

Afterwards, a new registration is created and a unique notification ID is
returned.
Notifications are recieved with the \verb'edg_wll_NotifReceive' call.
If no notification is ready for
delivery, the call waits until some notification arrival or timeout.

If user does not want to receive notifications any more, \verb'edg_wll_NotifDrop' call removes the registration for notifications from \LB server.


\subsection{Changing destination for notifications}

The second example illustrates how to receive notifications from different host or different application. 

Let us suppose that user is registered for receiving notifications on \LB\ server. She obtained a notification ID and information how long this registration will be valid as described in the previous example but she did not delete registration with \verb'edg_wll_NotifDrop'.

If the registration is still valid, she can start new client for receiving notifications, even from different machine, using notification ID returned during registration in previous step.

The sequence of function calls (without catching errors) would be as follows:

\begin{verbatim}
  edg_wll_NotifId         nid;
  char                    *ns;  // notification ID string returned 
                                // in previous example
  ...
  edg_wll_NotifIdParse(ns, &nid);
  edg_wll_NotifBind(ctx, nid, -1, NULL, &valid);

  /* prolong the registration validity if necessary */
  if (...validity close to expire...)
    edg_wll_NotifRefresh(ctx, nid, &valid);  

  edg_wll_NotifReceive(ctx, -1, &timeout, &status, &recv_notif_id);
  ...
\end{verbatim}

The call \verb'edg_wll_NotifReceive' will return any notification
that was generated while there was no listening client for it.
If there are none, it will wait for new notifications as in the previous
example.
