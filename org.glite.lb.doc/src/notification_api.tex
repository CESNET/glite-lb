% -*- mode: latex -*-

\section{\LB\ Notification API}
\label{s:Notification-API}

The \LB\ notification API is another kind of \LB\ consumer API which
provides streaming publish/subscribe model instead of query/response
model. It is designed to provide the same information and use the same
query conditions encoding as the consumer API described in
sec.~\ref{s:Consumer-API}

Basic usage of the \LB\ notification API is described in the \LB
user's guide (\cite{lbug}) in section ``Tools'' as there is described
a tool called \verb'glite-lb-notify' which is a command line interface
wrapper around the \LB\ notification API. Its source code can also
serve as a complete exaple of the \LB\ notification API usage.

The \LB\ notification API have currently fully implemented C language
binding and partially implemented C++ binding.

\subsection{Header files}
\begin{table}[h]
\begin{tabularx}{\textwidth}{>{\tt}lX}
glite/lb/notification.h & Prototypes for all notification API functions. \\
\end{tabularx}
\end{table}

\subsection{Call semantics}
The API have two main parts: notification subscription management and
receiving data. Each subscription (registration of notification) have
its unique identifier called \emph{Notification ID} represented by
type \verb'edg_wll_NotifId'. This ID is returned to the caller when
creating a new notification and it is used by receiver to get data
from the notification.

The API uses \verb'EDG_WLL_NOTIF_SERVER' context parameter to set the
source server (\LB server name and port). 

The typical notification workflow consist of 3 tasks:
\begin{itemize}
 \item Create a new notification registration based on given conditions.
 \item Refresh the registration. Each notification registration is
  soft-state registration and must be regullarly refreshed by the
  owner.
 \item Receiving the data from notification. The \LB infrastructure
  provides data queuing and garanteed delivery (while the registration
  is valid). 
\end{itemize}

The client notification library contains a code providing a pool of
receiving sockets/connections to optimize a parallel receiving of
notifications.

For complete reference of all API funcions please see the header
file. The next sessions briefly describe main facts about API
funcions.

\subsection{Notification subscription and management}
\begin{itemize}
 \item \emph{New notification} is created using
  \verb'edg_wll_NotifNew' call. The call needs properly initialized
  context and returns a unique notification ID. To create a new
  notification the same encoding of conditions as for the \LB
  query/response API is used (sec.~\ref{s:queryrec}). 

  In version 1.x
  there is a restriction that at least one particular JobId must be
  defined. In \LB 2.0 you cat make a registration based on other
  attributes without referencing a particular JobId (you can select
  owner, VO, network server).
  \TODO{JDL flags?} 

 \item \emph {Refresh of a notification} When a new notification is
  created using \verb'edg_wll_NotifNew' call, the notification
  validity parameter is intended to set the refresh period, not the
  lifetime of the notification itself. The owner of notification must
  periodically call \verb'edg_wll_NotifRefresh' to ensure validity of
  the notification.

 \item It is possible to \emph{change existing notification} (its conditions) by
  \verb'edg_wll_NotifChange' call.

 \item If user does not want to receive notifications any more,
  \verb'edg_wll_NotifDrop' call \emph{removes the registration} for
  notifications from \LB server.
\end{itemize}

\subsection{Receive data}
To receive data from a notificaton the API provides
\verb'edg_wll_NotifReceive' call. It returns first incoming
notification if at least one is available or waits a specified timeout. You can
also set the timeout to zero if you want to poll.

If the user wants to start receiving the notifications from different
machine than where the registration was done, it is possible. The
client must use the \verb'edg_wll_NotifBind' call to inform the
notification infrastructure (interlogger) about its location change.

The notification API cleanup procedure should be called when
finalizing the client (\verb'edg_wll_NotifClosePool' and 
\verb'edg_wll_NotifCloseFd' calls -- where the later is optional 
-- see the next section).

\subsection{Advanced aspects}

\subsubsection{External versus internal management of notification socket}
A notification socket used by \verb'edg_wll_NotifReceive' call to
receive the notifications is automatically created during the
\verb'edg_wll_NotifNew' or \verb'edg_wll_NotifBind' calls.

It the user wants to use its own socket (for example to be used in
main select() call) it can be created and closed by the user and set
as a parameter (fd) to all calls mentioned above.

When using automatically created socket it must be closed explicitly
by calling \verb'edg_wll_CloseFd'.

\subsubsection{Multiple registrations}
Each user can register for multiple notifications (call
\verb'edg_wll_NotifNew' function more than once). Every registration
gets its own notification ID and must be managed separately (refresh,
change, drop). But the \verb'edg_wll_NotifReceive' call is common for
all the registrations created in the same context (all previous
\verb'edg_wll_NotifNew' calls). 

If the user wants to distinguish between multiple registrations it is
needed to inspect a notification ID value of each received notification.

A \verb'edg_wll_NotifBind' works in similar way like
\verb'edg_wll_NotifNew'. For each notification ID it must be called
once and subsequent \verb'edg_wll_NotifReceive' call will work with
the whole set of registrations. Will receive a first notification from
any of registations.

\subsubsection{Operator CHANGED}

\subsection{Registering and receiving notification example}

The following example registers on \LB\ server to receive
notifications triggered by any event belonging to a
given user and waits for notification (until \verb'timeout').

%The glite-lb-bkserverd and glite-lb-notif-interlogd daemons have to be running. The first one user registers to, the second one delivers notifications to the example program (as described in \ref{notification}).

First we have to include neccessary headers:
\lstinputlisting[title={\bf File: }\lstname,numbers=left,linerange=headers-end\ headers]{notif_example.c}

Define and initialize variables and context. During context
initialization user's credentials are loaded and environment variable
\verb'GLITE_WMS_NOTIF_SERVER' is used as a LB notification server:
\lstinputlisting[title={\bf File:}\lstname,numbers=left,linerange=variables-end\ variables]{notif_example.c} 


Set the query record to \emph{all user's jobs}:
\lstinputlisting[title={\bf File: }\lstname,numbers=left,linerange=queryrec-end\ queryrec]{notif_example.c}

New registration based on prepared query record is created and a
unique notification ID is returned: 
\lstinputlisting[title={\bf File:}\lstname,numbers=left,linerange=register-end\ register]{notif_example.c}

The \verb'edg_wll_NotifReceive' call returns one notification. If no notification is 
ready for delivery, the call waits until some notification arrival or timeout:
\lstinputlisting[title={\bf File: }\lstname,numbers=left,linerange=receive-end\ receive]{notif_example.c}

% Finalizing the client

