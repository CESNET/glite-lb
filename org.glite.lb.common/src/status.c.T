#ident "$Header$"

#include <stdlib.h>
#include <string.h>

#include "glite/lb/consumer.h"

static const struct timeval null_timeval = {0,0};


void edg_wll_FreeStatus(edg_wll_JobStat *stat)
{ 
  if (stat) {
	int 	i;
    
@@@{
        selectType $status '_common_';
        for (getFieldsOrdered $status) {
                my $f = selectField $status $_;
                my $ft = $f->{type};
                if ($ft eq 'jobid') {
                        gen "\tedg_wlc_JobIdFree(stat->$_);\n";
                }
                if ($ft eq 'string') {
                        gen "\tif (stat->$_ != NULL )    \tfree(stat->$_);\n";
                }
                if ($ft eq 'intlist') {
                        gen "\tif (stat->$_ != NULL )    \tfree(stat->$_);\n";
                }
                if ($ft eq 'strlist') {
                        gen "\tif (stat->$_ != NULL ) {\n";
			gen "\t\tfor (i=0; stat->$_\[i]; i++)\n";
			gen "\t\t\tfree(stat->$_\[i]);\n";
			gen "\t\tfree(stat->$_);\n";
			gen "\t}\n";
                }
                if ($ft eq 'taglist') {
                        gen "\tif (stat->$_ != NULL ) {\n";
			gen "\t\tfor (i=0; stat->$_\[i].tag; i++) {\n";
			gen "\t\t\tfree(stat->$_\[i].tag);\n";
			gen "\t\t\tfree(stat->$_\[i].value);\n";
			gen "\t\t}\n";
			gen "\t\tfree(stat->$_);\n";
			gen "\t}\n";
                }
                if ($ft eq 'stslist') {
                        gen "\tif (stat->$_ != NULL ) {\n";
			gen "\t\tfor (i=0; stat->$_\[i].state; i++)\n";
			gen "\t\t\tedg_wll_FreeStatus(&stat->$_\[i]);\n";
			gen "\t\tfree(stat->$_);\n";
			gen "\t}\n";
                }

        }
@@@}
    
  }
}

edg_wll_JobStat *edg_wll_CpyStatus(const edg_wll_JobStat *src, edg_wll_JobStat *dest)
{
	int 	i;


	if ( !src || !dest )
		return NULL;

	edg_wll_InitStatus(dest);
    	dest->state = src->state;
@@@{
		selectType $status '_common_';
		for (getFieldsOrdered $status) {
			my $f = selectField $status $_;
			my $ft = $f->{type};
			if ($ft eq 'jobid') {
				gen "\tif ( edg_wlc_JobIdDup(src->$_, &(dest->$_)) ) goto err;\n";
			}
			if ($ft eq 'string') {
				gen "\tif ( src->$_ != NULL )\n";
				gen "\t\tif ( !(dest->$_ = strdup(src->$_)) ) goto err;\n";
			}
			if ($ft eq 'intlist') {
				gen "\tif ( src->$_ != NULL )\n\t{\n";
				gen "\t\ti = 1 + src->$_\[0];\n";
				gen "\t\tif ( !(dest->$_ = malloc(sizeof(*src->$_)*i)) ) goto err;\n";
				gen "\t\tmemcpy(dest->$_,src->$_,sizeof(*src->$_)*i);\n\t}\n";
			}
			if ($ft eq 'strlist') {
				gen "\tif ( src->$_ != NULL )\n\t{\n";
				gen "\t\tfor ( i = 0; src->$_\[i]; i++ ) ;\n";
				gen "\t\tif ( !(dest->$_ = malloc(sizeof(*src->$_)*(i+1))) ) goto err;\n";
				gen "\t\tfor ( i = 0; src->$_\[i]; i++ )\n";
				gen "\t\t\tif ( !(dest->$_\[i] = strdup(src->$_\[i])) ) goto err;\n";
				gen "\t\tdest->$_\[i] = NULL;\n\t}\n";
			}
			if ($ft eq 'stslist') {
				gen "\tif ( src->$_ != NULL )\n\t{\n";
				gen "\t\tfor ( i = 0; src->$_\[i].state; i++ ) ;\n";
				gen "\t\tif ( !(dest->$_ = malloc(sizeof(*src->$_)*(i+1))) ) goto err;\n";
				gen "\t\tfor ( i = 0; src->$_\[i].state; i++ )\n";
				gen "\t\t\tif ( !edg_wll_CpyStatus(&src->$_\[i], &dest->$_\[i]) ) goto err;\n";
				gen "\t\tdest->$_\[i].state = EDG_WLL_JOB_UNDEF;\n\t}\n";
			}
			if (($ft eq 'bool') or ($ft eq 'timeval') or ($ft eq 'logsrc')
				or ($ft eq 'port') or ($ft eq 'level') or ($ft eq 'int')) {
				gen "\tdest->$_ = src->$_;\n";
			}
			if ($ft eq 'taglist') {
				gen qq{
!	if (src->$_ != NULL) \{
!		for (i=0; src->$_\[i].tag; i++);
!		dest->$_ = malloc(sizeof(*src->$_)*(i+1));
!		for (i=0; src->$_\[i].tag; i++) \{
!			dest->$_\[i].tag = strdup(src->$_\[i].tag);
!			dest->$_\[i].value = strdup(src->$_\[i].value);
!		\}
!		dest->$_\[i].tag = NULL;
!        \}
				};
			}
		}
@@@}
    
  return dest;

err:
  edg_wll_FreeStatus(dest);
  return NULL;
}


int edg_wll_InitStatus(edg_wll_JobStat *stat)
{
	if (!stat) return -1;
	
	stat->state = EDG_WLL_JOB_UNDEF;

@@@{
        selectType $status '_common_';
        for (getFieldsOrdered $status) {
                my $f = selectField $status $_;
                gen "\tstat->$_ = $f->{null};\n"
        }
@@@}

	return 0;
}

static const char * const statNames[] = {
	"Undefined",
@@@{
        for (getTypesOrdered $status) {
                gen "\t\"$_\",\n";
        }
@@@}
};

edg_wll_JobStatCode edg_wll_StringToStat(const char *name)

{
        unsigned int     i;

        for (i=0; i<sizeof(statNames)/sizeof(statNames[0]); i++)
                if (strcasecmp(statNames[i],name) == 0) return (edg_wll_JobStatCode) i;
        return (edg_wll_JobStatCode) -1; 
}

char *edg_wll_StatToString(edg_wll_JobStatCode statCode)
{
        if ((int)statCode < 0 || statCode >= sizeof(statNames)/sizeof(statNames[0])) return (char *) NULL; 
        return strdup(statNames[statCode]);
}
