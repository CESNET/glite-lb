%
%% Copyright (c) Members of the EGEE Collaboration. 2004-2010.
%% See http://www.eu-egee.org/partners for details on the copyright holders.
%% 
%% Licensed under the Apache License, Version 2.0 (the "License");
%% you may not use this file except in compliance with the License.
%% You may obtain a copy of the License at
%% 
%%     http://www.apache.org/licenses/LICENSE-2.0
%% 
%% Unless required by applicable law or agreed to in writing, software
%% distributed under the License is distributed on an "AS IS" BASIS,
%% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
%% See the License for the specific language governing permissions and
%% limitations under the License.
%
\documentclass{egee}

\usepackage{graphicx}
\usepackage{amsbsy}
\usepackage{xspace}

\ifx\pdfoutput\undefined
\def\driver{dvips}
\def\vsuffix{eps}
\let\bsuffix=\vsuffix
\else
\def\driver{pdftex}
\def\vsuffix{pdf}
\def\bsuffix{jpg}
\fi

\def\LB{L\&B\xspace}
\def\ie{i.\,e.\xspace}
\def\eg{e.\,g.\xspace}
\def\wrt{w.\,r.\,t.\xspace}
%\def\labelitemi{\textbf{--}}


\title{\LB API Reference}
\DocIdentifier{EGEE-doc-identifier}
\Date{\today}
\Activity{JRA1: Middleware}
\DocStatus{DRAFT}
\Subtitle{just to show everything works} %No SubTitle
\Dissemination{PUBLIC}
\DocumentLink{http://cern.ch}
\Abstract{%
\LB API reference.
}


\begin{document}

\parindent=0pt
\parskip=\smallskipamount

\tableofcontents

\makeatletter
\def\jobid{\textit{JobId}\xspace}
\def\@tti[#1]{\item[{\normalfont\texttt{#1}}]\catcode`\_=8}
\def\tti{\catcode`\_=11\noexpand\@tti}
\newlength{\tw}

\def\synopsis{\catcode`\_=11\noexpand\@synopsis}
\def\@synopsis#1#2{
\tw=\linewidth
\advance\tw-2em
\texttt{#1(}\\
\strut\hskip2em\begin{tabularx}\tw{>{\begingroup\tt}l<{\endgroup}lX}
#2
\end{tabularx}\\
\texttt)
\catcode`\_=8
}

\def\Synopsis{\subsubsection*{Synopsis}}
\def\Description{\subsubsection*{Description}}
\def\Return{\subsubsection*{Return values}}

\begin{thebibliography}{9}
\bibitem[R1]{lbarch}\emph{\LB Architecture release 2}, DataGrid-01-TED-0141.
\bibitem[R2]{lbdraft}\emph{Logging and Bookkeeping Service for the DataGrid},
DataGrid-01-TEN-0109.
\bibitem[R3]{lbdraft2}
\emph{Logging and Bookkeeping Service for the DataGrid, release~2},
DataGrid-01-TEN-0132.
\bibitem[R4]{lbadvanced}
\emph{\LB Advanced Queries Extensions},
DataGrid-01-TEN-0125.
\bibitem[R5]{naming}\emph{Naming Conventions}, DataGrid-12-D12.2-0201.
\bibitem[R6]{draft-abela}\emph{draft-abela-ulm-05}.

\end{thebibliography}

\section*{Purpose of this Document}
This document provides a~consistent overview of the API to the \LB (logging and bookkeeping) service of WMS (workload management system) of the EU Datagrid
middleware.
It is inteded for both WP1 developers using the service,
as well as WP1-external users.

This document obsoletes previous documents providing the API
description~\cite{lbdraft,lbadvanced} and the respecive sections
of~\cite{lbdraft2}.

\newpage

\section{\LB Service Overview}
It is not a~purpose of this document to discuss architecture issues of
the \LB service.
However, we provide a~brief overview so that this document is more or less
self-contained.
Further details can be found in~\cite{lbdraft2} and mainly in~\cite{lbarch}.

Purpose of the service is monitoring a~job from being submitted to the WMS,
going through various stages of planning its execution, being run,
and finally either successfully or unsuccessfully terminating.
End users are able to query the service in order to get information on
an overall status of their jobs, as well as detailed logging information.

The service works with the following principal data entities:
\begin{description}
\item[Job] corresponds to a~user job (unit task) being submitted to the WMS.
A job is referenced with a~unique identifier -- \jobid.
\item[Event] is a~unit record on anything significant \wrt job life, \eg\ its
submission, assignment of a~suitable computing resource, starting execution
etc. An event is always uniquely associated to a~particular job.
\end{description}

\begin{figure}
\begin{center}
\includegraphics[width=.8\hsize]{fig/logging-arch.\vsuffix}
\end{center}
\caption{\LB service architecture}
\textbf{FIXME: make it up to date}
\label{f:arch}
\end{figure}

Figure~\ref{f:arch} shows principal components of the \LB service
and data flow among them. 

\textbf{TODO: daemons, dataflow}

\subsection{Events}
\label{s:events}

Every event carries event type and information necessary for identifying the
time and origin of the event (\jobid and string identifying the event
sender). In addition, in release~2, every event includes its sequence code (generated by logging library
when the event is logged, see Sect.~\ref{s:sequence}).
Event type determines additional
data that the event contains. Event types are as follows (because there are many
changes and clarifications since release~1, we list all event types including those with unchanged
type-specific data items):

\def\jobregister{\emph{Job\-Register}}
\def\jobtransfer{\emph{Job\-Transfer}}
\def\jobaccepted{\emph{Job\-Accepted}}
\def\jobrefused{\emph{Job\-Re\-fused}}
\def\jobenqueue{\emph{Job\-EnQueued}}
\def\jobdequeue{\emph{Job\-DeQueued}}

\def\helpercall{\emph{Helper\-Call}}
\def\helperret{\emph{Helper\-Return}}

\def\txfrev{\jobtransfer, \jobaccepted, \jobrefused}

\def\jobpending{\emph{Job\-Pending}}
\def\jobmatch{\emph{Job\-Match}}

\def\jobpurge{\emph{Job\-Purge}}
\def\jobabort{\emph{Job\-Abort}}
\def\jobcancel{\emph{Job\-Cancel}}
\def\jobrun{\emph{Job\-Run\-ning}}
\def\jobdone{\emph{Job\-Done}}
\def\jobcleared{\emph{Job\-Cleared}}
\def\jobresub{\emph{Job\-Resubmission}}

\def\jobchkpt{\emph{Job\-Chkpt}}
\def\joblistener{\emph{Job\-Listener}}
\def\jobcurjdl{\emph{Job\-Cur\-Descr}}

\subsubsection{Job transfer between components}

\begin{description}

\item[\jobtransfer] -- The sender of this event attempted to transfer a~job
to some other component via extenal interface, \eg UI to Network Server or JSS to Condor-G.
This event contains identification of the
other component which the job is being sent to (component name, hostname and network port number) and possibly the job
description being transferred in language this component accepts (job description for NS, RSL
for Globus job-manager, ClassAd for Condor-G).
Result, \ie{} success or failure, of the transfer (as seen by the sender)
and new internal job ID assigned by the other component (if known) must be included. Following result codes are recognized:
\begin{itemize}
\item START -- the sending component has started or is about to start the transfer
\item OK -- job was sent successfully
\item REFUSED -- job was refused by the other component
\item FAIL -- transfer failed for other reason than explicit refusal (\eg network timeout)
\end{itemize}

\item[\jobaccepted] -- Receiving component accepted the job via external interface. This
event pairs with \jobtransfer\ and should contain identification of the sending component (if possible) and the locally assigned job id (Condor, Globus, \dots).
This event is issued by the receiving component where possible (on JSS to Condor-G transfer, Log Monitor should log this event).

\item[\jobrefused] -- Receiving component could not accept the job, the reason being a part of the event. 

\item[\jobenqueue] -- The job is inserted into a queue, \eg the queue holding the job after it is received by Network Server and before it is processed by Workload Manager. The data items are the same as in \jobtransfer\ except new internal job ID is not present and the destination is interpreted as queue name.

\item[\jobdequeue] -- The job is removed from queue. The data items are the same as in \jobaccepted.

\item[\helpercall] -- Helper component is called during the job processing. The type-specific data include
the name of called Helper, whether the logging component is called or calling one, and optionally parameters
passed to the Helper.

\item[\helperret] -- Call to Helper returns.  The type-specific data include
the name of called Helper, whether the logging component is called or calling one, and optionally 
the return data from the Helper (\ie\ modified ClassAd or description of modifications to the input ClassAd).
\end{description}


\subsubsection{Job state changes during processing inside a component}

\begin{description}
\item[\jobrun] -- The job was started on the selected computing element
(its node) by the local resource management system.
\item[\jobresub] -- Reports the result of resubmission decision after the job has failed. Data items include
the result (will/won't be resubmitted), the reason string, and tag -- value of the attribute on which the decision is based.
\item[\jobdone] -- Job has exited, has been successfully cancelled or is considered to be in terminal state by Condor-G.
This event contains status code:
\begin{itemize}
\item OK -- the job has completed successfully from the point of view of WMS
(Unix return code can be non-zero)
\item FAIL -- the job has failed to run
\item CANCELLED -- the job was cancelled by user request
\end{itemize}
In addition to status code, reason for the change (especially with FAIL status code) and process exit code should be filled in, if available. 
\item[\jobcancel] -- Cancel operation has been attempted on the job. The event
carries the status code:
\begin{itemize}
\item REQ -- request acknowledged
\item REFUSE -- request declined by this component
\item DONE -- request completed by whole WMS
\item ABORT -- request refused by whole WMS
\end{itemize}
Reason string is also included.
\item[\jobabort] -- Job processing was stopped by WMS due to error condition, the event contains the reason for abort.
\item[\jobcleared] -- Job results (output files) were handed over to the user; all temporary files were removed.
\item[\jobpurge] -- Generated when the job is purged from bookkeping server's database. This event is stored only in
a logging server.
\end{description}


\subsubsection{Workload Manager or Helpers}

\begin{description}
\item[\jobmatch] -- Appriopriate match (\ie\ the CE) was found.
This event contains the ID of selected CE.
\item[\jobpending] -- This event is logged by WM when there was no match
found for given job (\eg\ not enough information was found, requested
resources are not available at the moment, job dependency condition is not
satisfied) and the job is going to be requeued.
The event describes reason why the jobs remains in the queue.
\end{description}

\subsubsection{Store special information in \LB}
\begin{description}
\item[\jobregister] -- Logged by job creator (UI or Job Partitioner) in order to register the job
or its subjobs with bookkeeping server. This event includes the job description (JDL), parent job ID
(if subjob), number of subjobs to create in \LB, and the seed for subjob ID generation. This event
should be logged synchronously for a job that is not a subjob of another job.

\item[\jobchkpt] -- An application-specific checkpoint was created (logged by checkpointing API).
Checkpoint tag and ClassAd strings should be included.
\item[\joblistener] -- Use by UI to store listener network port information for interactive jobs.
Listener port number, hostname and service name (multiple ports can be advertised) must be included.
\item[\jobcurjdl] -- This optional event can be used to report ClassAd describing the current
state of job processing (output from Helper modules).
\end{description}

\subsection{Event sources}
The following table describes which events should be logged by
particular workload management architecture components:
\\

{\raggedright

%\begin{table}[h]
\newlength\kratsi
\setlength{\kratsi}{\textwidth}
\addtolength{\kratsi}{-5mm}
\begin{tabularx}{\kratsi}{@{}lX}
UI & \jobregister, \joblistener, \jobtransfer, \jobcancel, \jobabort \\
NS & \jobaccepted, \jobrefused, \jobenqueue, \jobcancel, \jobabort \\
WM & \jobdequeue, \helpercall, \helperret, \jobenqueue, \jobpending, \jobcurjdl, \jobcancel, \jobabort \\
Helper & \helpercall, \helperret, \jobcurjdl, \jobmatch \\
JSS & \jobdequeue, \jobtransfer, \jobcancel, \jobabort \\
LM & \jobtransfer, \jobaccepted, \jobrefused, \jobrun, \jobresub, \jobenqueue, \jobdone, \jobcancel, \jobabort \\
user app. (CE) & \jobchkpt \\
Job Wrapper & optionally \jobrun, \jobdone \\
sandbox storage & \jobcleared \\
bkserver & \jobpurge\\
\end{tabularx}
%\end{table}
}% end of \raggedright

\subsection{Job Status}
\label{s:status}
During its life within WMS a~job passes a~sequence of \emph{job states}.
The following lists briefly describes all possible states.
\begin{description}
\item[\em Submitted] -- Job is entered by the user to the User Interface or registered by Job Partitioner but not yet transferred to Network Server for processing or not yet processed by DAGMan (if subjob)
\item[\em Waiting] -- Job has been accepted by NS and is waiting for Workload Manager processing or is being processed by WM or DAGMan's Helpers
(\eg WM is busy, no appropriate Computing\-Element (cluster) has been found yet, required dataset is not
available, job is waiting for resource allocation)
\item[\em Ready] -- The job has been processed by WM or DAGMan and their Helper modules (especially, appropriate ComputingElement has been found) but not yet transferred to the Computing Element (local batch system queue) via Job Submission Service and Condor-G
\item[\em Scheduled] -- Job is waiting in the queue on the ComputingElement (this state never occurs with DAG/partitioned job)
\item[\em Running] -- Job is running or DAGMan is processing its subjobs (if the job is DAG/partitioned) 
\item[\em Done] -- Job has exited or is considered to be in a terminal state by Condor-G (\eg submission to CE has failed in an unrecoverable way).
This also includes user-initiated cancellation of the job.
\item[\em Aborted] -- Job processing was aborted by WMS (waiting in the Workload Manager queue or ComputingElement for too long, over-use of quotas, expiration of
user credentials,~\ldots)
%\item[\em Cancelled] -- Job has been successfully cancelled by user request
\item[\em Cleared] -- Output sandbox was transferred to the user or removed due to the timeout

\end{description}

\section{API Design}

\subsection{General Conventions}

\textbf{TODO}

\subsubsection{Return values}
The return type of most of the API functions is return \verb'int'.
Unless specified otherwise the returned values are as follows:
\begin{description}
\item[0] success
\item[errno] an error occured, the nature of the error
matches meaning of one of standard \verb'<errno.h>' error codes.
\item[\LB specific] a~few errors can't be intuitively mapped to \verb'<errno.h>', therefore the are specific \LB error codes, starting from \verb'EDG_WLL_ERROR_BASE'.
\end{description}
See Sect.~\ref{s:error} for details on error handling.

Few API function return \verb'char *'. In such a~case \verb'NULL' indicates
an error, non-null value means success.

\subsection{Function arguments}
In the following description the function arguments are classified as follows:
\begin{description}
\item[IN] pure input argument, not modified by the function.
If it is a~pointer, the C prototype includes \verb'const' (which is omitted in
this document for the sake of readability).
\item[OUT] pure output argument. The function expects a~pointer and fills in
the pointed object.

If the argument is \verb'**', or a~structure containing pointers,
the returned objects are \emph{always} dynamically allocated,
and has to be freed when not used anymore.
The same holds for directly returned pointers.

\item[INOUT] an argument taken as an input and modified by the function.
Typically it is the \LB context.

\end{description}

\subsubsection{Datatypes}
The API uses two classes of custom datatypes:
\begin{description}
\item[opaque types] (\eg context, jobid) do not expose their structure
to the user.
The only way to access them is via the API functions.
The internal structure of those may be subject to change.

\item[transparent types] (\eg event, status) expose the structure to the
user. The structure is documented and no incompatible changes will be done
without notice.
\end{description}

\subsection{Job Identifier}
Handling of the \jobid is not restricted to the \LB subsystem only,
it belongs to the common part of the entire WMS software.
However, it is stronly related to the \LB service, therefore we describe
it here for completness.

\textbf{TODO}

\iffalse
\subsubsection{Interface}
%\code{\#include "edg/workload/common/jobid/jobid.h"}

\subsubsection{Datatypes}
\begin{description}
\tti[edg_wlc_JobId] Representation of the \jobid.
Opaque type, it's contents is hidden to the API users and should be
manipulated with the access methods only.
\end{description}
\subsubsection{Functions}
\fi




\subsection{Context and Parameter Settings}
\label{s:context}

All the API functions refer to a~\emph{context} argument.
The context type \verb'edg_wll_Context' is opaque.
Context objects preserve various status information
(\eg\ connection to server) among the API calls.
The API caller can create many context objects, those are guaranteed
to be independent on one another.
In this way thread-safety of the library is achieved --
one context object has to be used by only one thread at time.

Context is used to set and keep various parameters of the library
(\eg\ default server addresses, timeouts, \dots).
Upon initialization, all the parameters are assinged default values.
However, many of the parameters take their default value from environment
variables. If the corresponding environment variable is set,
the parameter is initialized to its value instead of the default.
Note that a~few parameters cannot be assigned default value; consequently
setting them either in environment or with an explicit API call
is mandatory before using the appropriate part of the API.

The context also stores details on errors of the recent API call.

For use with the \emph{producer} calls (see Sect.~\ref{s:producer})
the context has to be assigned a~single \jobid
(with the \verb'edg_wll_SetLoggingJob' call, see Sect.~\ref{s:sequence}),
and keeps track of an event \emph{sequence code} for the job 
(detailed description in~\cite{lbarch}).

\Synopsis
\synopsis{int edg_wll_InitContext}{
edg_wll_Context *&OUT&context to be initialized
}

\synopsis{void edg_wll_FreeContext}{
edg_wll_Context&IN&context to be freed
}
%
\Description
\verb'edg_wll_InitContext' allocates and initializes a~new context object.
\verb'edg_wll_FreeContext' performs the necessary cleanup (closing pending
connections etc.) and destroys the object.
%
\Return
\verb'edg_wll_InitContext' returns 0 on success,
ENOMEM if \verb'malloc' fails.

\Synopsis

\synopsis{int edg_wll_SetParam}{
edg_wll_Context context & INOUT & context to operate on\\
edg_wll_ContextParam param & IN & parameter to set (see bellow) \\
\dots & IN & parameter value to set\\
}

\synopsis{int edg_wll_GetParam}{
edg_wll_Context context & INOUT & context to operate on\\
edg_wll_ContextParam param & IN & parameter to get (see bellow) \\
\dots & OUT & pointer to output variable\\
}

\Description
\verb'edg_wll_SetParam' sets a~context parameter to a~given value.
If the value is NULL (pointer type) or 0 (int), the parameter is reset
to its default value (or the value given by environment variable),
in exactly the same way as on context initialization.

\verb'edg_wll_GetParam' retrieves the current value of the parameter.
Even if it is a~default, an actual value is always returned, not NULL or 0.

All the context parameters are described in the following list.
\def\paritem[#1]{\item[\normalfont EDG\_WLL\_PARAM\_#1]\leavevmode\hbox{}\\}
\begin{quote}
\begin{description}
\paritem[HOST]
Hostname that will appear as the source of generated events.

\begin{tabularx}\linewidth{@{}lX}
Type& \verb'char *'\\
Default& return value of \verb'gethostname'\\
Environment& GLOBUS\_HOSTNAME
\end{tabularx}

\paritem[SOURCE]
Identification of the service which is logging: 
\begin{itemize}
\item EDG\_WLL\_SOURCE\_USER\_INTERFACE
\item EDG\_WLL\_SOURCE\_NETWORK\_SERVER
\item EDG\_WLL\_SOURCE\_WORKLOAD\_MANAGER
\item EDG\_WLL\_SOURCE\_BIG\_HELPER
\item EDG\_WLL\_SOURCE\_JOB\_SUBMISSION
\item EDG\_WLL\_SOURCE\_LOG\_MONITOR
\item EDG\_WLL\_SOURCE\_LRMS
\item EDG\_WLL\_SOURCE\_APPLICATION
\end{itemize}

\begin{tabularx}\linewidth{@{}lX}
Type& \verb'edg_wll_Source'\\
Default& N/A, hence it must be set before any producer call\\
Environment& EDG\_WLL\_LOG\_SOURCE
(split according to the pattern ``source[/instance]'' eventually)
\end{tabularx}

\paritem[INSTANCE]
Identification of an instance of the service
if more than one may appear on a~single host.
In case of EDG\_WLL\_SOURCE\_APPLICATION the instance is supposed to
identify the concrete application too.

\begin{tabularx}\linewidth{@{}lX}
Type& \verb'char *'\\
Default& N/A\\
Environment& EDG\_WLL\_LOG\_SOURCE
(split according to the pattern ``source/instance'')\\
\end{tabularx}

\paritem[LEVEL]
Logging level, \ie\ severity of messages. Supported values
are:
\begin{itemize}
\item EDG\_WLL\_LOG\_SYSTEM -- \LB system important events,
\item EDG\_WLL\_LOG\_DEBUG -- debugging and informational events.
\end{itemize}

\begin{tabularx}\linewidth{@{}lX}
Type& \verb'edg_wll_Lvl'\\
Default& EDG\_WLL\_LOG\_SYSTEM\\
Environment& N/A
\end{tabularx}

\paritem[DESTINATION]
Name of the host where to send the events, \ie\ the local-logger machine.

\begin{tabularx}\linewidth{@{}lX}
Type& \verb'char *'\\
Default& localhost\\
Environment& EDG\_WLL\_LOG\_DESTINATION (split accorting to the pattern
``hostname[:port]'')
\end{tabularx}

\paritem[DESTINATION\_PORT]
Port where the local-logger listens.

\begin{tabularx}\linewidth{@{}lX}
Type& \verb'int'\\
Default& 9002\\
Environment& EDG\_WLL\_LOG\_DESTINATION (split accorting to the pattern
``hostname[:port]'')
\end{tabularx}

\paritem[LOG\_TIMEOUT]
Timeout for asynchronous logging calls.
Theoretically, it's not possible to set infinite timeout,
however, we suppose that the maximal possible value of \verb'struct timeval'
is sufficient.

\begin{tabularx}\linewidth{@{}lX}
Type& \verb'struct timeval *'\\
Default& \textbf{TODO}\\
Environment& EDG\_WLL\_LOG\_TIMEOUT
\end{tabularx}

\paritem[LOG\_SYNC\_TIMOUT]
Timeout for synchronous logging calls.

\begin{tabularx}\linewidth{@{}lX}
Type& \verb'struct timeval *'\\
Default& \textbf{TODO}\\
Environment& EDG\_WLL\_LOG\_SYNC\_TIMEOUT
\end{tabularx}

\paritem[QUERY\_SERVER]
Hostname of the \LB server to query,
applicable only for calls which do not specify \jobid explicitely.

\begin{tabularx}\linewidth{@{}lX}
Type& \verb'char *'\\
Default& N/A, hence must be set before a~call which requires the value\\
Environment& EDG\_WLL\_QUERY\_SERVER (split according to the pattern
``hostname[:port]'' eventually)
\end{tabularx}

\paritem[QUERY\_SERVER\_PORT]
\LB server port. 

\begin{tabularx}\linewidth{@{}lX}
Type& \verb'int'\\
Default& 9000\\
Environment& EDG\_WLL\_QUERY\_SERVER (split according to the pattern
``hostname[:port]'')\\
\end{tabularx}

\paritem[QUERY\_TIMEOUT]
Maximal time to wait for a~response to a~query.

\begin{tabularx}\linewidth{@{}lX}
Type& \verb'struct timeval *query_timeout'\\
Default& \textbf{TODO}\\
Environment& EDG\_WLL\_QUERY\_TIMEOUT
\end{tabularx}

\paritem[QUERY\_LIMIT]
Maximal number of records that a~query may return.
It is used to prevent overloading both server and network by queries that
may return unusably huge datasets.

\begin{tabularx}\linewidth{@{}lX}
Type& \verb'int'\\
Default& unlimited\\
Environment& N/A
\end{tabularx}

\paritem[X509\_PROXY]
X509 proxy credentials file for logging or querying authentication.

\begin{tabularx}\linewidth{@{}lX}
Type& \verb'char *'\\
Default& GSI credential search mechanism is applied\\
Environment& X509\_USER\_PROXY
\end{tabularx}

\paritem[X509\_KEY]
X509 key file to use for logging or querying authentication.
X509\_CERT has to be set to a~matching certificate file.
If X509\_PROXY is set, X509\_KEY and X509\_CERT parameters are ignored.

\begin{tabularx}\linewidth{@{}lX}
Type& \verb'char *'\\
Default& GSI credential search mechanism is applied\\
Environment& X509\_USER\_KEY
\end{tabularx}

\paritem[X509\_CERT]
X509 certificate file for logging or querying authentication.
X509\_KEY has to be set to a~matching key file.
If X509\_PROXY is set, X509\_KEY and X509\_CERT parameters are ignored.

\begin{tabularx}\linewidth{@{}lX}
Type& \verb'char *'\\
Default& GSI credential search mechanism is applied\\
Environment& X509\_USER\_CERT
\end{tabularx}




\end{description}
\end{quote}

\Return
The functions return 0 on success and EINVAL if \verb'param'
is not a~valid context parameter.


\subsection{Error Handling}
\label{s:error}

Besides returning an error code,
the API calls record any error details within the \LB context.

Further on, the API distinguishes between \emph{hard} and \emph{soft}
errors.
In the case of soft error some output data may still be available
(\eg E2BIG -- the result is too big so that it is truncated but its part
is still available).
In case soft errror it is the user responsibility to check the output
and free the data eventually.
Possible soft errors are always indicated in the API description.

\Synopsis
\synopsis{int edg_wll_Error}{
edg_wll_Context	ctx & IN & context\\
char ** text	& OUT & standard error message\\
char ** desc	& OUT & error details (if any)\\
}

\Description
Retrieve recent API call error.
Besides an error code a~standard error message related to the code
is returned (\eg ``No such file or directory'' in the case of ENOENT),
and any details on the error (\eg it should be the filename in the case of 	ENOENT).
Any of \verb'text' of \verb'desc' can be NULL. No value is retrieved then.

\Return
The code of recent error.


\subsection{Event and Job Status Representation}
In the producer part events are not handled as explicit objects --
on the other hand, they are created on the fly by the logging calls,
based on context data as well as the particular functions arguments.

The consumer API part represents an event as a~union \verb'edg_wll_Event'
defined as follows:
\begin{quote}
\begin{verbatim}
typedef union _edg_wll_Event {
       edg_wll_EventCode        type;
       edg_wll_AnyEvent         any;
       edg_wll_TransferEvent    transfer;
       ...
} edg_wll_Event;

typedef struct _edg_wll_AnyEvent {
       edg_wll_EventCode        type;
       struct timeval           timestamp;
       char                     *host;
       int                      level;
       int                      priority;
       edg_wlc_JobId            jobId;
       char                     *seqcode;
       char                     *user;
       edg_wll_Source           source;
       char                     *src_instance;
} edg_wll_AnyEvent;
\end{verbatim}

\end{quote}

The \verb'edg_wll_AnyEvent' contains the common fields of all the event types.
It's guaranteed that the same fields are contained in all the event type
specific structures (\verb'edg_wll_TransferEvent' etc.) on matching positions.
Therefore it's always legal to access the \verb'type' union field to find
out the type of event, and then \verb'any' for the common fields only,
or the corresponding type-specific structure.

Full definitions of the structures including field types are presented
in Appendix~\ref{a:events}.

Job status is represented by a~flat \verb'edg_wll_JobStat' structure
(as there is more overlap of data fields among various job states,
following the event union scheme is irrelevant).
Among others, the structure contains the fields:
\def\ttitem[#1]{\item[\normalfont\texttt{#1}]}
\begin{quote}
\raggedright
\begin{description}
\ttitem[state] -- numeric code of the status (EDG\_WLL\_JOB\_SUBMITTED, EDG\_WLL\_JOB\_WAITING, \dots)
\ttitem[type] -- type of the job (EDG\_WLL\_JOB\_SIMPLE or EDG\_WLL\_JOB\_DAG)
\ttitem[children] -- list of subjob \jobid's
\ttitem[children\_histogram] -- number of children in particular states
\ttitem[children\_states] -- full status information of the children
\end{description}
\end{quote}
Note that not all the fields are always filled in, see Sect.~\ref{s:jobstat}.
Full description of the structure can be found in Appendix~\ref{a:events}.

\subsection{Connection Management}
The producer and consumer parts of the \LB API involve two communication
channels.
Connection data are stored within the context object.
Management of the corresponding network connections is performed 
transparently by the \LB
library and it is hidden to the API user.

The connections are soft-state: they may or may not be preserved across
subsequent API calls, the library may also cache several connections to
different servers.

%\subsection{Environment Variables}

\subsection{Producer}
\label{s:producer}
The \emph{producer} part of the library is responsible for
pushing the events into the \LB infrastructure.
It operates in the following modes:
\begin{description}
\item[Asynchronous] calls return as soon as possible, even if
the destination \LB server or a~network connection is down.
A~successful return from the API call
indicates that the event has been accepted by the \LB infrastructure,
persistently stored on the local-logger disk, and will be delivered to
the \LB server reliably.
However, there is no guarantee on time when the delivery actually occurs.

In addition, the API provides a~flush call to ensure that the previously
sent events are actually stored at the server.
\item[Synchronous] calls do not return successfully
until the logged event is stored at the server. 
This may take indefinite time.
A~synchornous call is not equivalent to a~corresponding asynchronous one
followed by the flush call -- synchronous events get precedence,
they may get stored while other previously logged
events heading to the same server may still be delayed (\eg\ because of
slow link).

Even synchronous calls needn't wait for completition of the operation
undefinitely.
On the contrary, the library defines a~timeout for synchronous calls
(see EDG\_WLL\_PARAM\_LOG\_TIMEOUTS in Sect.~\ref{s:context}),
despite the default value is much larger than for asynchronous counterparts.

\end{description}

In general, plain asynchronous calls should be used whenever possible.
Despite asynchronous they are still reliable.
The entire \LB service was initially designed and is optimized for delivery of 
asynchronous events.
The synchornous calls and mainly the flush call can take long time and consume
considerable amount of resources, therefore they should be used with care.
The API users are encouraged to design their code with the asynchronicity
of the \LB service in mind rather then relying on synchronous calls.

\iffalse
Connection between the \LB library and a~local-logger daemon
is established transparently on the logging calls and may or may not be cached.
The following context parameters are taken in account:
\begin{description}
\item[log\_host, log\_port] -- local-logger daemon to connect to,
\item[proxy\_file, key\_file, cert\_file] -- user identity,
\item[log\_async\_timeout, log\_sync\_timeout] -- timeout values for asynchronous and synchronous calls,
\item[log\_level, log\_service, log\_instance] -- current logging level, and identification of the service.
\end{description}
Some of the paramaters need not be set, environment variables as well as default
values are considered then. See Sect.~\ref{s:context} for details.
\fi

The producer part of the API can be split further into the following
groups:
\begin{itemize}
\item \emph{Sequence code handling calls} allow to retrieve and set the current
sequence code (used by the \LB service for clock-skew resistent event ordering).
\item \emph{Job registration calls} register a~job (and its subjobs)
with the \LB service.
\item \emph{Generic logging calls} capable of logging any defined event.
\item \emph{Specialized logging calls} -- one function per event.
\end{itemize}

\subsubsection{Sequence Code Handling}
\label{s:sequence}

\Synopsis
\synopsis{char *edg_wll_GetSequenceCode}{
edg_wll_Context context&IN&where to retrieve the code from\\
}

\synopsis{int edg_wll_SetLoggingJob}{
edg_wll_Context context&INOUT&the context to use\\
edg_wlc_JobId job&IN&\jobid to use in following logging calls\\
char *code&IN&code string as received from the previous component\\
int flags&IN&one of EDG_WLL_SEQ_NORMAL or EDG_WLL_SEQ_DUPLICATE\\
}

\Description
\LB service uses the \emph{sequence codes} to disambiguate the seqence
of events generated by a~job cycling among several WMS components
(\eg\ failure and resubmission) in an environment where clocks needn't
be strictly synchronized.
Details of the mechanism can be found in~\cite{lbarch}.

Each WMS component, when it passes control of a~job to another component,
is responsible for retrieving the sequence code from the current logging
context (via \verb'edg_wll_GetSequenceCode')
and pass it as an opaque string to the receiving component via their common
communication protocol (\eg\ within a~ClassAd attribute).
The receiving component initializes its logging context for the given job
(via \verb'edg_wll_SetLoggingJob')
with the received string before calling any logging functions.

If the job control passes through a~component several times but the
component is stateless (\eg\ the Log Monitor),
it may happen that this call is issued several times with the same
\verb'code'.
In such a~case this must be identified with the
EDG\_WLL\_SEQ\_DUPLICATE flag. \LB service relies on event timestamps then.
\emph{Despite unavoidable in some situations this option is dangerous; 
its misuse can emerge into incorrect job status computation.}
Therefore usage of this flag should be cross-checked with~\cite{lbarch}
whether all conditions required for proper \LB functionality are met.

\Return

\subsubsection{Job Registration}

\Synopsis

\synopsis{int edg_wll_RegisterJob}{
edg_wll_Context context& IN& logging context\\
edg_wlc_jobid job&IN&\jobid of the registered job\\
int type&IN&one of EDG_WLL_JOB_SIMPLE or EDG_WLL_JOB_DAG\\
char *jdl&IN&original (user specified) JDL of the job\\
char *ns&IN& contact string (URL) of the Network Server handling the job\\
int num_subjobs&IN&number of subjobs \\
char *seed&IN& seed for generating the subjobs \jobid's\\
edg_wlc_JobId **subjobs&OUT& array of generated subjob \jobid's\\
}

\synopsis{int edg_wll_RegisterJobSync}{\dots}

\synopsis{int edg_wll_RegisterSubjobs}{
edg_wll_Context context&IN& logging context\\
edg_wlc_JobId *parent&IN& parent \jobid\\
char **jdls&IN& JDL's of the subjobs\\
edg_wlc_JobId *subjobs&IN& array of subjob \jobid's\\
}

\Description
\verb'edg_wll_RegisterJob' sets the current job of the logging context to
\verb'job', initializes the corresponding sequence code, and registers 
the job (including certain critical information -- NS contact, and implicitly
the job owner) with \LB service via logging a~special event.
If the job is a~DAG the \verb'edg_wll_RegisterJob'
also generates the required number of subjob \jobid's and 
creates the $\textit{parent}\rightarrow\textit{children}$ association
at the \LB server.
The \verb'seed' argument is used to initialize the subjob \jobid generator.
It's guaranteed that given the same seed and parent \jobid, the
same sequence of \jobid's is generated.

A~component should also call \verb'edg_wll_RegisterJob' when job type (simple
or DAG) changes.

\verb'edg_wll_RegisterJob' is a~synchronous variant of the call,
it takes exactly the same arguments.
The synchronous call is usually prefered when registering a~job for the first
time. Further change of the type can be usually logged with the more efficient 
plain (asynchronous) call.

Complementary, the \verb'edg_wll_RegisterSubjobs' call
registers each of the \verb'subjobs' and creates the
$\textit{child}\rightarrow\textit{parent}$ associations at the \LB server.


\subsubsection{Generic Logging Calls}

\Synopsis
\synopsis{int edg_wll_LogEvent}{
edg_wll_Context context & INOUT & context to work with \\
edg_wll_EventCode event & IN & event type \\
char *fmt & IN & format string \\
\dots& IN & event specific values according to \verb'fmt'
}

\synopsis{int edg_wll_LogEventSync}{
edg_wll_Context context & INOUT & context to work with \\
edg_wll_EventCode event & IN & event type \\
char *fmt & IN & format string \\
\dots& IN & event specific values according to \verb'fmt'
}

\synopsis{int edg_wll_LogFlush}{
edg_wll_Context context & INOUT & context to work with \\
struct timeval *timeout & INOUT & wait at most this much time for completition, 
remaining time on return
}

\synopsis{int edg_wll_LogFlushAll}{
edg_wll_Context context & INOUT & context to work with \\
struct timeval *timeout & INOUT & wait at most this much time for completition,
remaining time on return
}

\Description
\verb'edg_wll_LogEvent' (asynchronous) 
and \verb'edg_wll_LogEventSync' (synchronous) are generic  logging functions.
The event type (as described in Sect.~\ref{s:events}) is determined by the 2nd
argument. The API defines corresponding constants with prefix 
\verb'EDG_WLL_EVENT_'.

The 3rd argument \verb'fmt' is expected to be a~\verb'printf'-like
format string which, together with the remaining arguments, builds
a well-formed ULM~\cite{draft-abela} string.
For each of the described event types there's a~predefined string constant
prefixed with \verb'EDG_WLL_FORMAT_'.

\verb'edg_wll_LogFlush' instructs the interlogger daemon to deliver
all pending events related to the current job
and waits at most \verb'timeout' for completition.
\verb'edg_wll_LogFlushAll' does the same for all jobs known to the
interlogger (as the events may originate from other processes,
the caller has no control on destination servers -- therefore the
FlushAll call may take unpredictable time).

\Return
The function return the following codes and set the error details within
the context:

\begin{tabularx}\hsize{lX}
0 & successful completition \\
EINVAL & bad \jobid, unknown event code, or the format string together
with the remaining arguments does not form a~valid event, \\
ENOSPC & \LB infrastructure failed to accept the event due to lack of disk
space etc., \\
ENOMEM & failed to allocate memory, \\
ECONREFUSED & cannot connect to the specified local logger, \\
EAGAIN & non-blocking return (\eg\ timeout) -- needn't be an error,
the event still may be delivered but we can't guarantee it anymore
(even in the case of synchronous call).
It makes sense to attempt logging the same event later, duplicates are ignored.
\\
\end{tabularx}

\begin{tabularx}\hsize{lX}
EDG\_WLL\_ERROR\_NOJOBID & logging call attempted without assigning \jobid
to the context (see Sect.~\ref{s:sequence}).
\end{tabularx}

In addition, the synchronous call may return further errors propagated
from the \LB server:

\begin{tabularx}\hsize{lX}
EPERM & the user is not authorized to add events to this job, \\
EEXIST & exactly the same event
has been already stored (this could be reported due to the synchronous
nature of the call, but the duplicates' treatment is exactly the same as
in asynchronous call\,---\,they are ignored).\\
\dots \\
\end{tabularx}

\iffalse
The \verb'edg_wll_LogFlush' call may also return:

\begin{tabularx}\hsize{lX}
EDG\_WLL\_ERROR\_INTERLOG\_TIMEOUT& The local-logger was contacted but the inter-logger
did not respond within the timeout,\\
EDG\_WLL\_ERROR\_INTERLOG\_CONLOST& Inter-logger lost connection to one or more
servers,\\
EDG\_WLL\_ERROR\_INTERLOG\_AGAIN& Not all pending events were delivered
within the timeout.
\end{tabularx}
\fi

\subsubsection{Specialized Logging Calls}

Besides the generic logging calls the API also provides specialized
calls for each event type (see Appendix~\ref{a:special} for details). 
Those calls don't include the \verb'event' argument (as the even type
is given by the function name) and the format string (the format is fixed
for a~given event type).
The number as well as types of further arguments are determined
by the event type hence fixed.


\subsubsection{Logging User Information}
Besides the ``system'' \LB events used to track a~job during its life within
WMS, the \LB service also supports \emph{user} events.
In this way, users are able to log and retrieve application-specific
information.

All the information is pushed into \LB service via the \emph{UserTags} event, 
containing one or more $\textit{name}=\textit{value}$ pairs.
%The events can be logged either with generic logging calls or with
%the following shortcut:

\Synopsis
\synopsis{edg_wll_LogUserTag}{
edg_wll_Context context &IN& logging context\\
char * name&IN& name of the tag\\
char * value&IN& corresponding value\\
}

\iffalse	
\synopsis{edg_wll_LogUserTags}{
edg_wll_Context context &IN& logging context\\
char ** names &IN& names of the tags\\
char ** values & IN& corresponding values of the tags\\
}
\fi

\Description
The first call logs a~simple \emph{UserTags} event,
containing a~sigle  $\textit{name}=\textit{value}$ pair.
The second call is a~more general variant allowing to log more
pairs within a~single event -- it is provided for performance reasons;
it should be used when more pairs are logged simultaneously.
From the point of view of further status queries \verb'edg_wll_LogUserTags' or
a~sequence of several corresponding \verb'edg_wll_LogUserTag''s is equivalent,
as long as the \verb'names' are distinct.


\subsection{Consumer}

%\subsubsection{Job Status}
%\label{s:status}

\subsubsection{Job Status Query}
\label{s:jobstat}
\Synopsis
\synopsis{int edg_wll_JobStatus}{
edg_wll_Context context & IN& context\\
edg_wlc_JobId	jobid & IN & \jobid of the job being queried\\
%int resolution & IN & resolution of the state machine, currently only
%EDG_WLL_STAT_STD\\
int flags & IN & bitwise OR of EDG_WLL_STAT_* constants (see bellow)
determining which of the optional status fields should be retrieved\\
edg_wll_JobStat *status & OUT & structure to fill in
}

\Description
The call queries the \LB server which stores information about the \verb'job'
(possibly opening a~network connection to the server)
and retrieves the job status information.

The \verb'flags' argument deterimines which of the result structure fields
will be actually filled, in addition to all ``basic'' fields
which are always returned:
\def\rmitem[#1]{\item[\normalfont#1]}
\begin{quote}
\begin{description}
%\rmitem[EDG\_WLL\_STAT\_BASIC] -- only ``short'' fields, \ie\ all except
%job descriptions (JDL, various ClassAd's, RSL, \dots) and any subjob information,
%
\rmitem[EDG\_WLL\_STAT\_CLASSADS] -- job description fields,
\rmitem[EDG\_WLL\_STAT\_CHILDREN] -- list of subjob \jobid's,
\rmitem[EDG\_WLL\_STAT\_CHILDSTAT] -- apply the flags recursively to
all subjobs.
\end{description}
\end{quote}


\Return
\begin{tabularx}\hsize{lX}
0&success\\
EINVAL& Invalid argument, \eg\ unknown or inappropriate condition,
invalid \jobid object etc.\\
EPERM& User is not authorized to retrieve data on this job.\\
ENOENT& The job was not found. \\
ECONREFUSED& Connection refused, \eg\ the server is not running.
\end{tabularx}


\subsubsection{General Queries}
\Synopsis
\synopsis{int edg_wll_QueryJobs}{
edg_wll_Context context& INOUT& context\\
edg_wll_QueryRec *conditions& IN & query conditions\\
int flags &IN& status fields to retrieve (see Sect.~\ref{s:jobstat})\\
edg_wll_JobId **jobs&OUT& matching \jobid's \\
edg_wll_JobStat **states &OUT& states of matching jobs (if requested)\\
}

\Description
Query the \LB server given by the context parameters
QUERY\_SERVER (see Sect.~\ref{s:context}).
Return the jobs  satisfying all the query conditions (see bellow).

The \verb'edg_wll_QueryRec' structure specifies an atomic query condition 
and is defined as follows:

\begin{verbatim}
typedef struct _edg_wll_QueryRec {
        edg_wll_QueryAttr       attr;   
        edg_wll_QueryOp         op;    
        char                    *tag;  
        union {
                int             i;      
                char            *c;    
                struct timeval  t;    
                edg_wlc_JobId   j;
        } value, value2;
} edg_wll_QueryRec;
\end{verbatim}

The atomic condition is always a~comparison of an \emph{atrribute}
and value of a~given type provided in an appropriate member of the
\verb'value' union. 

Valid comparisons are 
EDG\_WLL\_QUERY\_OP\_EQUAL,
EDG\_WLL\_QUERY\_OP\_LESS,
EDG\_WLL\_QUERY\_OP\_GREATER,
and EDG\_WLL\_QUERY\_OP\_WITHIN.
Meaning of the former three ones is straightforward
the last operation is a~check whether the attribute falls
into the interval given by \verb'value' (low limit) and \verb'value2'
(high limit). 
It becomes useful with more complex and-or queries (see bellow).

\def\qitem[#1]{\item[\normalfont EDG\_WLL\_QUERY\_ATTR\_#1]}

\verb'edg_wll_QueryJobs' retrieves information on jobs for which the
\emph{current} status satisfies the query conditions.
Attributes valid for quering are:
\begin{quote}
\begin{description}
\qitem[JOBID] (\verb'edg_wlc_JobId'). \jobid.
If this attribute is specified, the server hostname/port taken from
the \jobid is used instead of the QUERY\_SERVER context parameter.
\qitem[OWNER] (\verb'char *'). Job owner (X509 certificate subject).
\qitem[STATUS] (\verb'int'). Job status, see Sect.~\ref{s:status}.
\qitem[LOCATION] (\verb'char *'). Hostname of the machine where the job is 
being processed.
\qitem[DESTINATION] (\verb'char *'). Computing Element where the job was, is, or will be executed.
\qitem[DONECODE] (\verb'int'). Minor status of job termination, 
one of EDG\_WLL\_STAT\_DONE\_OK, EDG\_WLL\_STAT\_DONE\_FAIL, or EDG\_WLL\_STAT\_DONE\_CANCEL, see Sect.~\ref{s:status}.
\qitem[USERTAG] (\verb'char *').
User defined tag, the tag name has to be specified in \verb'tag'.
User tags are also interpreted in the ``status'' manner --
if several \emph{UserTags} events containing the same tag name were logged,
the new value overwrites the older ones.
\end{description}
\end{quote}
In addition, \verb'edg_wll_QueryJobs' called with nonzero \verb'flags'
also returns states of the matching jobs. 
The meaning of \verb'flags' is the same as for \verb'edg_wll_JobStatus'.

\Return
\begin{tabularx}\hsize{lX}
0&success\\
EINVAL& Invalid argument, \eg\ unknown or inappropriate condition,
invalid \jobid object etc.\\
EPERM (soft)& The user is not authorized to access all data matching
the query. \\
ENOENT& No jobs satisfying the query conditions were found.\\
E2BIG (soft)& Result set size exceeds either the size set by the context parameter
QUERY\_LIMIT or the server imposed limit.
The call still returns the truncated output.\\
ECONREFUSED& Connection refused, \eg\ the server is not running.
\end{tabularx}

\begin{tabularx}\hsize{lX}
EDG\_WLL\_ERROR\_NOINDEX & The query is refused by the server being
too general, potentially causing server overload. See the discussion
in Sect.~\ref{s:index}.
\end{tabularx}

\Synopsis
\synopsis{int edg_wll_QueryJobsExt}{
edg_wll_QueryRec **conditions& IN & query conditions\\
int flags &IN& status fields to retrieve (see Sect.~\ref{s:jobstat})\\
edg_wll_JobId **jobs&OUT& matching \jobid's \\
edg_wll_JobStat **states &OUT& states of matching jobs (if requested)\\
}

\def\attr{\textit{attr}}
\def\val{\textit{val}}
\def\And{\textrm{\ and\ }}
\def\Or{\textrm{\ or\ }}

\Description
A~more general ``and-or'' variant of \verb'edg_wll_QueryJobs'.
It allows queries in the form 
$$
(\attr_1 = \val_a \Or \attr_1 = \val_b) \And (\attr_2 = \val_c \Or \attr_2=\val_d \Or \attr_3=\val_e)
$$
The \verb'conditions' are not an array of atomic conditions
but an array (NULL-terminated) of pointers to arrays of conditions.
All conditions in one of the inner arrays should always refer
the same attribute, and are considered logicaly OR-ed,
\ie\ at least one of the conditions within the array has to be satisfied.
On the other hand, the arrays as a~whole are considered logicaly AND-ed.

The restriction on the structure of the query expression (two nested
levels only) as well as enforcing the same attribute within conditions at the
lower level are imposed due to performance reasons.
An arbitrary complex queries might easily result into unacceptable load on
the \LB\ server.
On the other hand, we believe that a~vast majority of feasible queries
is covered with this interface.

\Return
Same as \verb'edg_wll_QueryJobs'. In addition EINVAL is returned also
when conditions in one or more inner arrays does not refer to the same
attribute.


\Synopsis
\synopsis{int edg_wll_QueryEvents}{
edg_wll_Context context& INOUT& context\\
edg_wll_QueryRec *job_conditions& IN & query conditions on current job status\\
edg_wll_QueryRec *event_conditions& IN & query conditions on the events\\
edg_wll_Event **events &OUT& matching events\\
}

\Description
Query the \LB server given by the context parameters
QUERY\_SERVER (see Sect.~\ref{s:context}).
Return the events satisfying 
\verb'job_conditions' and \verb'event_conditions'.
If \verb'job_conditions' is not null, the \emph{current} states of the 
the jobs, which the retrieved events are related to, have to satisfy the 
conditions.
In addtion, further conditions can be applied on the retrieved events.

Valid attributes for \verb'job_conditions' are same as for
\verb'edg_wll_QueryJobs'.

Valid attributes for \verb'event_conditions' are:
\begin{quote}
\begin{description}
%\qitem[JOBID] (\verb'edg_wlc_JobId'). \jobid.
%\qitem[OWNER] (\verb'char *'). Job owner.
\qitem[TIME] (\verb'struct timeval *'). Event timestamp.
\qitem[LEVEL] (\verb'int'). Logging level.
\qitem[HOST] (\verb'char *'). Hostname where the event was generated.
\qitem[SOURCE] (\verb'int'). Service which logged the events,
see the SOURCE context parameter in Sect.~\ref{s:context} for allowed values.
\qitem[INSTANCE] (\verb'char *'). Instance of the service, see Sect.~\ref{s:context} for details.
\qitem[EVENT\_TYPE] (\verb'int'). Event type, see Sect.~\ref{s:events}.
\qitem[USERTAG] (\verb'char *').
User defined tag, the tag name has to be specified in \verb'tag'.
User tags among event conditions are interpreted in a~different way
\wrt\ those in job status. 
All events from the whole job history are retrieved
if they satisfy the conditions, not only the most recent one.

\end{description}
\end{quote}

\Return
Same as \verb'edg_wll_QueryJobs'.

\Synopsis
\synopsis{int edg_wll_QueryEventsExt}{
edg_wll_Context context& INOUT& context\\
edg_wll_QueryRec **job_conditions& IN & query conditions on current job status\\
edg_wll_QueryRec **event_conditions& IN & query conditions on the events\\
edg_wll_Event **events &OUT& matching events\\
}

\Description
\begin{sloppypar}
Analogous ``and-or'' extension of \verb'edg_wll_QueryEvents'.
See the description of \verb'edg_wll_QueryJobsExt' for details
on the allowed query structure and exact meaning of arguments.
\end{sloppypar}

\subsubsection{Convenience Wrappers}

\Synopsis
\synopsis{edg_wll_UserJobs}{
edg_wll_Context context &INOUT \\
edg_wlc_JobId **jobs &OUT & \jobid's of the current user's jobs\\
edg_wll_JobStat **states &OUT & states of the jobs \\
}

\synopsis{edg_wll_JobLog}{
edg_wll_Context context &INOUT \\
edg_wlc_JobId job &IN& \jobid to query \\
edg_wll_Event **events &OUT& retrieved events
}

\Description
\verb'edg_wll_UserJobs' queries the current server for all jobs of the
current user.
If the \verb'states' argument is not null, BASIC (see Sect.~\ref{s:jobstat})
states of the jobs are retrieved as well.

\verb'edg_wll_JobLog' retrieves all events related to a~given job.

\Return
Same as \verb'edg_wll_QueryJobs' (the functions are wrappers around
the general queries only).

\subsubsection{Server Indexed Attributes}
\label{s:index}
The consumer API is quite general, allowing the caller to submit
a wide range of queries.
On the other hand,
a na\"\i ve query can easily emerge into a~full scan of the \LB server
database. As the database is expected to grow very large, the full scan
is unacceptable due to performance reasons.

In order to allow efficient queries, the server has to index certain attributes
and use the indices as primary selection criteria.
Each server indexes the data on JOBID and OWNER of the job.
In addition the
server's configuration can specify a~further set of indexed attributes
including enumerated user tags.
The user tags are indexed in both their job-status and event-related semantics.

Each query must include at least one condition on an indexed attribute.
Otherwise, the query is rejected by the server.

\Synopsis
\synopsis{int edg_wll_GetIndices}{
edg_wll_Context context &INOUT\\
edg_wll_QueryAttr **attrs&OUT& array of indexed attributes\\
char ***userTags &OUT& array of indexed user tags\\
}
\Description
Query the server configuration for indexed attributes.
Returns the indexed standard \LB attributes in \verb'attrs'
and possibly the indexed user tags in \verb'userTags'.

\subsubsection{Result Set Size}
In order to further prevent inefficient queries which may result in a~very huge
result set, causing both server and network overload, the consumer
part of the \LB service can impose two limits on the result set size:
\begin{itemize}
\item \emph{Server side} (hard) limit is given by the server configuration,
and it cannot be changed by the user.
\item \emph{Client side} (soft) limit is stored within a~context object
and can be set by the user.
\end{itemize}
The limits are expressed as a~maximal number of entries (\ie\ jobs or events)
returned. 
On each query, the client advertises its current limit to the server,
and the server enforces the smaller one of the two limits then.

Should a~query result in a~larger output, the result is truncated but still
returned to the caller.
Triggering the limit is indicated by returning E2BIG error code.

The client limit can be manipulated with the Set/Get parameter calls
(see Sect.~\ref{s:context}).

\Synopsis
\synopsis{edg_wll_GetServerLimit}{
edg_wll_Context & INOUT \\
int	*limit &OUT & server limit
}

\Description
Retrieve the current server query result size limit.


\section{C++ Binding}
C++ \LB{} server API is closely modelled after the C \LB{} server
API. It consists of the following classes:
\begin{description}

\item{\emph{JobId}}\\
Class representing \jobid; this class is not in
fact part of C++ \LB API, as it is shared by all WP1 components.

\item{\emph{LoggingException}}\\
Derived from
\emph{edg::workload::common::utilities::Exception}, this class
communicates the error conditions back to C++ \LB API clients.

\item{\emph{ServerConnection}}\\
Encapsulates the notion of context of C \LB API. All
functions taking as the parameter the \emph{edg\_wll\_Context} and not specific
to jobs are reflected in methods of \emph{ServerConnection} class. 

\item{\emph{Job}}\\
Represents the job and defines job specific query methods;
all C \LB API functions taking as parameters \emph{edg\_wll\_Context} and
\emph{edg\_wlc\_JobId} are reflected here. 

\item{\emph{JobStatus}}\\
Closely related to the \emph{Job} class, this class holds data
about job status, ie. the attribute -- value pairs specific
for a given job state. 

\item{\emph{Event}}\\
Represents events stored in the bookkeeping
server database; the data are stored as attribute -- value pairs.

\item{\emph{QueryRecord}}\\
A helper class for specifying queries to \LB
database. 
\end{description}

\noindent More detailed description of these classes and their methods
follows.

\subsection*{LoggingException}

\subsection*{QueryRecord}
Class used to create \verb|AND| queries to the \LB
database, encapsulates \emph{edg\_qll\_QueryRec}. Every object of that
class holds a condition on exactly one attribute of the result; query
methods then take vectors of \emph{QueryRecord} objects as parameters
with logical \verb|AND| semantics. 

\subsubsection*{Constants}
\begin{description}
\item{
\begin{verbatim}
  enum Attr {
    UNDEF=0,	/**< Not-defined value, used to terminate lists etc. */
    JOBID,	/**< Job Id \see _edg_wll_QueryRec */
    OWNER,	/**< Job owner \see _edg_wll_QueryRec */
    STATUS,	/**< Current job status */
    LOCATION,	/**< Where is the job processed */
    DESTINATION,/**< Destination CE */
    DONECODE,	/**< Minor done status (OK,fail,cancel) */
    USERTAG,	/**< User tag (not implemented yet) */
    TIME,	/**< Timestamp \see _edg_wll_QueryRec */
    LEVEL,	/**< Logging level (see "dglog.h") * \see _edg_wll_QueryRec */
    HOST,	/**< Where the event was generated */
    SOURCE,	/**< Source component */
    INSTANCE,	/**< Instance of the source component */
    EVENT_TYPE,	/**< Event type \see _edg_wll_QueryRec */
  };

  enum Op { EQUAL=1, LESS, GREATER };
\end{verbatim}
 These constants are used to identify attributes and conditions on
them. Listed attributes are the only ones permitted to query, they
form a subset of all possible attributes.
}
\end{description}

\subsubsection*{Constructors}
\begin{description}
\item{
\begin{verbatim}

QueryRecord(const Attr, const Op, const std::string &);
QueryRecord(const Attr, const Op, const int);
QueryRecord(const Attr, const Op, const struct timeval &);
QueryRecord(const Attr, const Op, const edg::workload::common::jobid::JobId&);
\end{verbatim}
}
There is a constructor for every attribute type allowed in a
query. Supported types include integers, strings, times and \jobid's.

\end{description}

\subsection*{Event}
This class provides methods for getting event attribute names and
values.

\subsubsection*{Constructors}
Constructors are used internally by the library, as the client is not
suposed to create objects of \emph{Event} class.

\subsubsection*{Event type}
\begin{description}
\item{

\begin{verbatim}
	enum Type {
		UNDEF = 0,
		TRANSFER,	/**< Start, success, or failure of job transfer to another component */
		ACCEPTED,	/**< Accepting job (successful couterpart to Transfer) */
		REFUSED,	/**< Refusing job (unsuccessful couterpart to Transfer) */
		ENQUEUED,	/**< The job has been enqueued in an inter-component queue */
		DEQUEUED,	/**< The job has been dequeued from an inter-component queue */
		HELPERCALL,	/**< Helper component is called */
		HELPERRETURN,	/**< Helper component is returning the control */
		RUNNING,	/**< Executable started */
		RESUBMISSION,	/**< Result of resubmission decision */
		DONE,		/**< Execution terminated (normally or abnormally) */
		CANCEL,		/**< Cancel operation has been attempted on the job */
		ABORT,		/**< Job aborted by system */
		CLEAR,		/**< Job cleared, output sandbox removed */
		PURGE,		/**< Job is purged from bookkepping server */
		MATCH,		/**< Matching CE found */
		PENDING,	/**< No match found yet */
		REGJOB,		/**< New job registration */
		CHKPT,		/**< Application-specific checkpoint record */
		LISTENER,	/**< Listening network port for interactive control */
		CURDESCR,	/**< current state of job processing (optional event) */
		USERTAG,	/**< user tag -- arbitrary name=value pair */
		TYPE_MAX
	};
\end{verbatim}
}
Symbolic constants defining possible event types.

\item{\verb|Type type|}\\
The event type given by one of the constants above.

\item{\verb|const std::string & name(void) const|}\\
Returns string representation of the event's type (ie. ``JobDone'').

\end{description}

\subsubsection*{Attributes}
\begin{description}
\leftmargin10pt\listparindent20pt

\item{\verb|enum AttrType { INT_T, STRING_T, TIMEVAL_T, PORT_T, LOGSRC_T, JOBID_T }|}\\
Constants determining event attribute types. 

\item{\verb|const std::vector<std::pair<Attr,AttrType> >  &getAttrs(void) const|}\\
This method returns the vector of attribute name and type pairs. The
type is given by the symbolic constant above, for a list of possible
attributes see the header file {\tt edg/workload/logging/client/Event.h}.

\item{
\begin{verbatim}
int		getValInt(Attr) const
std::string 	getValString(Attr) const
struct timeval	getValTime(Attr) const
const edg::workload::common::jobid::JobId getValJobId(Attr) const
\end{verbatim}
}
Methods for accessing event attribute's value. There is one method for
every supported attribute type. For some attributes the returned
integer values can be defined by symbolic constants; for a list of
allowed constants see the header file
{\tt edg/workload/logging/client/Event.h}. 
The \verb|int getValInt(Attr)| method should be used for 
the \verb|PORT_T| and \verb|LOGSRC_T| attribute types.

\item{\verb|const std::string & getAttrName(Attr) const|}\\
Converts a symbolic attribute name to string representation.

\end{description}

\subsection*{ServerConnection class}
Objects of this class represent one bookkeeping server. Underlying
network connections are handled automatically by the library, the
class defines methods for setting connection parameters and general
queries to the \LB database.

\subsubsection*{Constructors}
\begin{description}
\item{\verb|ServerConnection()|}\\ Creates new object and initializes
it according to the environment variables. 
\end{description}

\subsubsection*{Query parameters}
These methods are dealing with various parameters of connection to the
\LB server. The connections however are managed intrinsically by the
library itself.

\begin{description}
\item{\verb|void setQueryServer(const std::string&)|}\\
Set the hostname of \LB server to query.

\item{\verb|void setQueryTimeout(int)|}\\
Set timeout for server response.

\item{\verb|void setX509Proxy(const std::string&)|}\\
Use the X509 proxy stored in file named in parameter for
authentication. 

\item{\verb|void setX509Cert(const std::string&, const std::string&)|}\\
Use X509 certificate (certificate filename in the first parameter, private
key stored in file named in the second parameter) for authentication.

\item{\verb|std::pair<std::string, int> getQueryServer() const|}\\
Returns the hostname and port of the currently used \LB server.

\item{\verb|int getQueryTimeout() const|}\\
Returns currently used query timeout.

\end{description}

\subsubsection*{Queries}
\begin{description}
\item{\verb|std::vector<std::string> singleTags(void)|}\\
\item{\verb|std::vector<std::vector<std::string> > multiTags(void)|}\\

\item{\verb|std::pair<int,int> getLimits(void) const|}\\
Get the hard (first) and soft (second) limit on the number of results
(records) returned by the \LB server in one query.

\item{\verb|void setSoftLimit(int)|}\\
Set the soft (client side) limit on the number of query results.

\item{
\begin{verbatim}
void queryEvents(
const std::vector<QueryRecord>& job_cond,
const std::vector<QueryRecord>& event_cond,
std::vector<Event>&) const;
\end{verbatim}
}
Return all events satisfying conditions in the second parameter logged
by jobs satisfying conditions in the first parameter. Result is in the
last parameter.

\item{
\begin{verbatim}
std::string queryEventsAggregate(
const std::vector<QueryRecord>& job_cond,
const std::vector<QueryRecord>& event_cond,
enum AggOp const op,
std::string const attr) const;
\end{verbatim}
}
The same as above, but do not return particular events. The result of
aggregation operation (currently minimum, maximum and number of
results) on attribute in the fourth parameter is returned instead.

\item{
\begin{verbatim}
void queryJobs(
const std::vector<QueryRecord>& query,
std::vector<edg::workload::common::jobid::JobId>& ids) const;
\end{verbatim}
}
Return \jobid's of jobs satisfying the query conditions in the first
parameter, result is in the second parameter.

\item{
\begin{verbatim}
void queryJobStates(
const std::vector<QueryRecord>& query, 
int flags,
std::vector<JobStatus> & states) const;
\end{verbatim}
}
Return states of jobs satisfying the conditions in the first
parameter. The second parameter determines the detail of information
returned on each job, result is in the last parameter.

\item{\verb|void userJobs(std::vector<edg::workload::common::jobid::JobId> &) const|}\\
Returns \jobid's of all jobs owned by the user (as determined by the
X509 proxy or certificate) known by the \LB server.

\item{\verb|void userJobStates(std::vector<JobStatus>& stateList) const|}\\
Same as above, but return job states instead of \jobid's.

\end{description}

\subsection*{Job}
The \emph{Job} class represent individual job in the \LB database and
provides methods for accessing it's state and events stored in the \LB
database.

\subsubsection*{Constructors}
\begin{description}
\item{\verb|Job(void)|}\\
Default constructor, creates empty object.

\item{\verb|Job(const edg::workload::common::jobid::JobId &)|}\\
Creates object representing job with given \jobid.
\end{description}

\subsubsection*{Job properties}
\begin{description}

\item{
\begin{verbatim}
static const int STAT_CLASSADS;       /**< various job description fields */
static const int STAT_CHILDREN;       /**< list of subjob JobId's */
static const int STAT_CHILDSTAT;      /**< apply the flags recursively to subjobs */
\end{verbatim}
}
These constants differentiate the level of detail returned in job
status information by the \LB. 

\item{\verb|JobStatus status(int) const|}\\
Returns \emph{JobStatus} object holding information about the job, the
requested level of detail is passed as an argument determined by the
above constants.

\item{\verb|void log(std::vector<Event> &) const|}\\
Fill in the passed vector argument with all events logged for this job.

\item{\verb|const std::pair<std::string,uint16_t> queryListener(const std::string & name) const|}\\
Return the name and port of the listener for interactive jobs. 

\end{description}

\subsection*{JobStatus}
The \emph{JobStatus} class represents the result of job status query
to the \LB database. 

\subsubsection*{Constructors}
All constructors are used internally by the \LB client library.

\subsubsection*{Properties}
All information about job status are encoded as an attribute
name--value pairs, for every attribute type there is a corresponding 
method to obtains that attribute's value. 

\begin{description}

\item{
\begin{verbatim}
int	getValInt(Attr) const;
std::string getValString(Attr) const;
struct timeval	getValTime(Attr) const;
const edg::workload::common::jobid::JobId  getValJobId(Attr) const;
bool getValBool(Attr) const;
const std::vector<int> getValIntList(Attr) const;
const std::vector<std::string> getValStringList(Attr) const;
const std::vector<JobStatus> getValJobStatusList(Attr) const;
\end{verbatim}
}
Access methods for various attribute types. Each method takes an
attribute symbolic name as an argument. 

\end{description}

\subsection*{Event}
The \emph{Event} class represents one event stored in the \LB
database. All information about particular event are accessible as an
attribute name--value pairs. Every type of event (and instance of the 
\emph{Event} class) defines set of mandatory and optional attributes.


\subsubsection*{Constructors}
Constructors are used internally by the \LB client library.

\subsubsection*{Properties}

\begin{description}
\item{
\verb|const std::vector<std::pair<Attr,AttrType> >  &	getAttrs(void) const;|
}\\
Return list of defined attributes for this instance. The attributes
are given as a name--type pairs, where both name and type are given by
symbolic constants. For every supported attribute type there is a
corresponding method to obtain value of such attribute; in addition
values of enumerated types (whose values are defined as symbolic
constants and there is a \emph{edg\_wll\_<type>ToString()} function)
can be obtained in string form by calling the \emph{getValString()} method.

\item{
\begin{verbatim}
int	getValInt(Attr) const;
std::string getValString(Attr) const;
struct timeval	getValTime(Attr) const;
const edg::workload::common::jobid::JobId  getValJobId(Attr) const;
const std::string & getAttrName(Attr) const;
\end{verbatim}
}
Access methods for supported attribute types, argument is an symbolic
name of the requested attribute.

\end{description}

% \section{Use Cases}

\appendix
\section{Event and Job Status Structures}
\label{a:events}
\section{Specialized Logging Calls}
\label{a:special}

\end{document}
