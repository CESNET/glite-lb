#ifndef __GLITE_LB_PRODUCER_H__
#define __GLITE_LB_PRODUCER_H__

/**
 * \file producer.h
 * \brief client API for storing data into L&B service
 */

#ident "$Header$"
/*
@@@AUTO
*/
@@@LANG: C

#ifdef __cplusplus
extern "C" {
#endif

#include "glite/lb/context.h"
#include "glite/lb/events.h"

/* Event sources: */

#if 0 /* obsolete */
#define EDG_WLL_SOURCE_UI           "UserInterface"
#define EDG_WLL_SOURCE_RB           "ResourceBroker"
#define EDG_WLL_SOURCE_JSS          "JobSubmissionService"  /* aka Condor-G */
#define EDG_WLL_SOURCE_JOBMGR       "GlobusJobmanager"
#define EDG_WLL_SOURCE_LRMS         "LocalResourceManager"
#define EDG_WLL_SOURCE_APP          "Application"

#define EDG_WLL_SOURCE_NS	"NetworkServer"
#define EDG_WLL_SOURCE_WM	"WorkloadManager"
#define EDG_WLL_SOURCE_BH	"BigHelper"
#define EDG_WLL_SOURCE_LM	"LogMonitor"

#endif

/* edg_wll_LogEvent shortcuts */
@@@{
for my $t (sort { $event->{order}->{$a} <=> $event->{order}->{$b} }
		$event->getTypes) {
	my $tu = uc $t;
	my $a = "(edg_wll_Context context";
	my $b = "(context,EDG_WLL_EVENT_$tu,EDG_WLL_FORMAT_$tu";
	my $doc = qq{
 * \\param[in,out] context\tcontext to work with,
};
	selectType $event $t;
	for ($event->getFieldsOrdered) {
		my $f = selectField $event $_;
		my $fn = $f->getName;
		my $ft;
                if ($f->{codes}) {
#                        $ft = "enum edg_wll\_$t" . ucfirst $fn;
                        $ft = "char *";
                } else {
                        $ft = $f->getType;
                }
		$ft = "const ".$ft;
		my $fc = $f->getComment;
		$a = $a . ", $ft $fn";
		$b = $b . ", $fn";
		$doc = $doc . " * \\param[in] $fn\t$fc\n";
	}
	$a = $a . ")";
	$b = $b . ")";
	gen qq{
/**
 * \\fn int edg_wll_Log$t$a; 
 * \\brief simple wrapper around edg_wll_LogEvent for event $t} . $doc . qq{ * \\see edg_wll_LogEvent\(\)
 */
};
	gen "\nextern int edg_wll_Log${t}$a;\n";
	gen "\nextern int edg_wll_Log${t}Proxy$a;\n";
#	gen qq{
#int edg_wll_Log$t$a
#\{
#	return edg_wll_LogEvent$b;
#\}\n
#};
	for ($event->getFieldsOrdered) {
		my $f = selectField $event $_;
		my $fn = $f->getName;
		my $ft;
                if ($f->{codes}) {
#                        $ft = "enum edg_wll\_$t" . ucfirst $fn;
                        $ft = "char *";
                } else {
                        $ft = $f->getType;
                }
		my $ftreg = $ft;
		$ftreg =~ s/\*/\\\*/g;
		$ftreg = "const ".$ftreg;
		my $fc = $f->getComment;
		if ($f->{codes}) {
			for (@{$f->{codes}}) {
				my $code = uc $_->{name};
				my $c = $a;
				my $d = $b;
				my $e = $doc;
				$c =~ s/, $ftreg $fn//g;
				$d =~ s/$fn/"$code"/g;
# FIXME: this documentation line in $e doesn't delete!!
				$e =~ s/ \* \\param\[in\] $fn\t$fc\n//g;
				gen qq{
/**
 * \\fn int edg_wll_Log$t$code$c; 
 * \\brief simple wrapper around edg_wll_LogEvent for event $t, $fn $code} . $e . qq{ * \\see edg_wll_LogEvent\(\)
 */
};
				gen "\nextern int edg_wll_Log$t${code}$c;\n";
				gen "\nextern int edg_wll_Log$t${code}Proxy$c;\n";
#				gen qq{
#int edg_wll_Log$t$code$c
#\{
#	return edg_wll_LogEvent$d;
#\}\n
#};
			}
		}
	}
}
@@@}


/**
 * Formats a logging message and sends it asynchronously to local-logger
 * \brief generic asynchronous logging function
 * \param[in,out] context	context to work with,
 * \param[in] event		type of the event,
 * \param[in] fmt		printf()-like format string,
 * \param[in] ...		event specific values/data according to fmt,
 * \retval 0		successful completition,
 * \retval EINVAL	bad jobId, unknown event code, or the format string together with the remaining arguments does not form a valid event,
 * \retval ENOSPC	L&B infrastructure failed to accept the event due to lack of disk space etc.,
 * \retval ENOMEM	failed to allocate memory,
 * \retval ECONNREFUSED	cannot connect to the specified local logger,
 * \retval EAGAIN	non blocking return from the call, the event may or may not get logged,
 * \retval EDG_WLL_ERROR_NOJOBID logging call attempted without assigning jobId to the context.
 */
extern int edg_wll_LogEvent(
	edg_wll_Context context,
	edg_wll_EventCode event,
	char *fmt, ...);

/**
 * Formats a logging message and sends it synchronously to local-logger
 * \brief generic synchronous logging function
 * \param[in,out] context	context to work with,
 * \param[in] event		type of the event,
 * \param[in] fmt		printf()-like format string,
 * \param[in] ...		event specific values/data according to fmt,
 * \retval 0		successful completition,
 * \retval EINVAL	bad jobId, unknown event code, or the format string together with the remaining arguments does not form a valid event,
 * \retval ENOSPC	L&B infrastructure failed to accept the event due to lack of disk space etc.,
 * \retval ENOMEM	failed to allocate memory,
 * \retval ECONNREFUSED	cannot connect to the specified local logger,
 * \retval EAGAIN	non blocking return from the call, the event may or may not get logged,
 * \retval EDG_WLL_ERROR_NOJOBID logging call attempted without assigning jobId to the context,
 * \retval EPERM	the user is not authorized to add events to this job,
 * \retval EDG_WLL_ERROR_DB_DUP_KEY exactly the same event has been already stored.
 */
extern int edg_wll_LogEventSync(
	edg_wll_Context context,
	edg_wll_EventCode event,
	char *fmt, ...);

/**
 * Formats a logging message and sends it synchronously to L&B Proxy
 * \brief generic synchronous logging function
 * \param[in,out] context	context to work with,
 * \param[in] event		type of the event,
 * \param[in] fmt		printf()-like format string,
 * \param[in] ...		event specific values/data according to fmt,
 * \retval 0            successful completition,
 * \retval EINVAL       bad jobId, unknown event code, or the format string together with the remaining arguments does not form a valid event,             
 * \retval ENOSPC       L&B infrastructure failed to accept the event due to lack of disk space etc.,
 * \retval ENOMEM       failed to allocate memory,
 * \retval ECONNREFUSED cannot connect to the specified L&B Proxy
 * \retval EAGAIN       non blocking return from the call, the event may or may not get logged,
 * \retval EDG_WLL_ERROR_NOJOBID logging call attempted without assigning jobId to the context.
 */             
extern int edg_wll_LogEventProxy(
        edg_wll_Context context, 
        edg_wll_EventCode event,
        char *fmt, ...);        

/**
 * Instructs interlogger to to deliver all pending events related to current job
 * \brief flush events from interlogger
 * \note sort of status query more than a command
 * \param[in,out] context	context to work with,
 * \param[in,out] timeout	wait at most this much time for completition, remaining time on return,
 * \retval 0		successful completition,
 * \retval EDG_WLL_ERROR_INTERLOG_TIMEOUT the inter-logger did not respond within the timeout,
 * \retval EDG_WLL_ERROR_INTERLOG_CONLOST inter-logger lost connection to one or more servers,
 * \retval EDG_WLL_ERROR_INTERLOG_AGAIN   not all pending events were delivered within the timeout.
 */
extern int edg_wll_LogFlush(
	edg_wll_Context context,
	struct timeval *timeout);


/**
 * Instructs interlogger to to deliver all pending events
 * \brief flush all events from interlogger
 * \note same as edg_wll_LogFlush() for all jobs known to interlogger
 * \see edg_wll_LogFlush()
 */
extern int edg_wll_LogFlushAll(
	edg_wll_Context context,
	struct timeval *timeout);

/**
 * Set a current job for given context.
 * \note Should be called before any logging call.
 * \param[in,out] context 	context to work with
 * \param[in] job 		further logging calls are related to this job
 * \param[in] code 		sequence code as obtained from previous component
 * \param[in] flags 		flags on code handling (\see API documentation)
 */
extern int edg_wll_SetLoggingJob(
	edg_wll_Context	context,
	const edg_wlc_JobId	job,
	const char *		code,
	int			flags
);

/**
 * Set a current job for given context.
 * \note Should be called before any logging call.
 * \param[in,out] context 	context to work with
 * \param[in] job 		further logging calls are related to this job
 * \param[in] code 		sequence code as obtained from previous component
 * \param[in] user 		user credentials
 * \param[in] flags 		flags on code handling (\see API documentation)
 */
extern int edg_wll_SetLoggingJobProxy(
	edg_wll_Context	context,
	const edg_wlc_JobId	job,
	const char *		code,
	const char *		user,
	int			flags
);

/**
 * Register job with L&B service.
 * Done via logging REGJOB event, may generate subjob id's and create
 * the parent-children associations.
 * Set the job as current for the context and initialize sequence code.
 *
 * Partitionable jobs should set num_subjobs=0 initially,
 * and re-register when number of subjobs becomes known.
 *
 * \param[in,out] context 	context to work with
 * \param[in] job 		jobId
 * \param[in] type 		EDG_WLL_JOB_SIMPLE,  EDG_WLL_JOB_DAG, or EDG_WLL_JOB_PARTITIONABLE
 * \param[in] jdl 		user-specified JDL
 * \param[in] ns 		network server contact
 * \param[in] num_subjobs 	number of subjobs to create
 * \param[in] seed 		seed used for subjob id's generator.
 * 	Use non-NULL value to be able to regenerate the set of jobid's
 * \param[out] subjobs 		returned subjob id's
 */

/* backward compatibility */
#define EDG_WLL_JOB_SIMPLE	EDG_WLL_REGJOB_SIMPLE
 
extern int edg_wll_RegisterJob(
	edg_wll_Context		context,
	const edg_wlc_JobId	job,
	enum edg_wll_RegJobJobtype	type,
	const char *		jdl,
	const char *		ns,
	int			num_subjobs,
	const char *		seed,
	edg_wlc_JobId **	subjobs
);

/** 
 * Synchronous variant of edg_wll_RegisterJob
 */

extern int edg_wll_RegisterJobSync(
	edg_wll_Context		context,
	const edg_wlc_JobId	job,
	enum edg_wll_RegJobJobtype	type,
	const char *		jdl,
	const char *		ns,
	int			num_subjobs,
	const char *		seed,
	edg_wlc_JobId **	subjobs
);

/**
 * Register job with L&B Proxy service.
 * Done via logging REGJOB event, may generate subjob id's and create
 * the parent-children associations.
 * Set the job as current for the context and initialize sequence code.
 *
 * Partitionable jobs should set num_subjobs=0 initially,
 * and re-register when number of subjobs becomes known.
 *
 * \param[in] type 		EDG_WLL_JOB_SIMPLE, EDG_WLL_JOB_DAG, or EDG_WLL_JOB_PARTITIONABLE
 * \param[in] user 		user credentials
 * \param[in] jdl 		user-specified JDL
 * \param[in] ns 		network server contact
 * \param[in] num_subjobs 	number of subjobs to create
 * \param[in] seed 		seed used for subjob id's generator.
 *      Use non-NULL value to be able to regenerate the set of jobid's
 * \param[out] subjobs 		returned subjob id's
 */

extern int edg_wll_RegisterJobProxy(
	edg_wll_Context		context,
	const edg_wlc_JobId	job,
	enum edg_wll_RegJobJobtype	type,
	const char *		jdl,
	const char *		ns,
	int			num_subjobs,
	const char *		seed,
	edg_wlc_JobId **	subjobs
);

#ifdef LB_PERF
/* original register to LBProxy 	*/
extern int edg_wll_RegisterJobProxyOld(
	edg_wll_Context		context,
	const edg_wlc_JobId	job,
	enum edg_wll_RegJobJobtype	type,
	const char *		jdl,
	const char *		ns,
	int			num_subjobs,
	const char *		seed,
	edg_wlc_JobId **	subjobs
);

/* register only to LBProxy 		*/
/* useful for performance measurements	*/

extern int edg_wll_RegisterJobProxyOnly(
	edg_wll_Context		context,
	const edg_wlc_JobId	job,
	enum edg_wll_RegJobJobtype	type,
	const char *		jdl,
	const char *		ns,
	int			num_subjobs,
	const char *		seed,
	edg_wlc_JobId **	subjobs
);
#endif



/**
 * Register subjobs in a batch.
 * Mainly used to provide JDL's of individual subjobs in a more efficient
 * way than logging them one by one.
 * \param[in] jdls		array of JDL's
 * \param[in] subjobs 		array of jobid's in the same order
 */

extern int edg_wll_RegisterSubjobs(
	edg_wll_Context		context,
	const edg_wlc_JobId	parent,
	char const * const *	jdls,
	const char *		ns,
	edg_wlc_JobId const *	subjobs
);


/**
 * Register subjobs to LB Proxyin a batch.
 * Mainly used to provide JDL's of individual subjobs in a more efficient
 * way than logging them one by one.
 * \param[in] jdls		array of JDL's
 * \param[in] subjobs 		array of jobid's in the same order
 */

extern int edg_wll_RegisterSubjobsProxy(
	edg_wll_Context		context,
	const edg_wlc_JobId	parent,
	char const * const *	jdls,
	const char *		ns,
	edg_wlc_JobId const *	subjobs
);

/**
 * Generate or regenerate set of subjob ID's.
 * Calls the same algorithm used to generate subjob ID's in edg_wll_RegisterJob().
 * Local semantics only, server is not contacted.
 */

extern int edg_wll_GenerateSubjobIds(
	edg_wll_Context		context,
	const edg_wlc_JobId	parent,
	int			num_subjobs,
	const char *		seed,
	edg_wlc_JobId **	subjobs
);


enum edg_wll_Permission {
	EDG_WLL_PERM_READ  = 1,
	EDG_WLL_PERM_WRITE = 4,
	EDG_WLL_PERM_ADMIN = 8,
};

enum edg_wll_PermissionType {
	EDG_WLL_PERM_ALLOW,
	EDG_WLL_PERM_DENY,
};

enum edg_wll_ACLOperation {
	EDG_WLL_ACL_ADD,
	EDG_WLL_ACL_REMOVE,
};

enum edg_wll_UserIdType {
	EDG_WLL_USER_SUBJECT,		/* X.509 subject name */
	EDG_WLL_USER_VOMS_GROUP,	/* VOMS group membership */
};

/**
 * Change ACL for given job.
 * \param[in,out] context 	context to work with
 * \param[in] job 		jobId
 * \param[in] user_id 		specification of user's credential
 * \param[in] user_id_type 	type of user_id,
 *    for EDG_WLL_USER_SUBJECT the user_id parameter is expected to be user's subject name
 *    for EDG_WLL_USER_VOMS_GROUP the user_id is expected to be of the form VO:group specifying required group membersip as managed by VOMS
 * \param[in] permission 	ACL permission to change
 * \param[in] permission_type 	type of given permission (allow or deny operation) 
 * \param[in] operation 	operation to perform with ACL (add or remove record)
 */
 
extern int edg_wll_ChangeACL(
	edg_wll_Context		context,
	const edg_wlc_JobId	job,
	const char *		user_id,
	enum edg_wll_UserIdType	user_id_type,
	enum edg_wll_Permission		permission,
	enum edg_wll_PermissionType	permission_type,
	enum edg_wll_ACLOperation	operation
);


#ifdef __cplusplus
}
#endif

#endif /* __GLITE_LB_PRODUCER_H__ */
