#!/usr/bin/perl

use Getopt::Long;

my $pwd = `pwd`; chomp $pwd;
my $prefix = $pwd.'/stage';
my $staged;
my $module;
my $thrflavour = 'gcc64dbgpthr';
my $nothrflavour = 'gcc64dbg';
my $mode = 'build';
my $help = 0;

my @nodes = qw/client server logger utils java doc/;
my %enable_nodes;
my %disable_nodes;

my %extern_prefix = (
	cares => '/opt/c-ares',
	classads => '/opt/classads',
	cppunit => '/usr',
	expat => '/usr',
	globus => '/opt/globus',
	gsoap => '/usr',
	mysql => '/usr'
);


my %glite_prefix;
my %need_externs;
my %extrafull;
my %extranodmod;
my %deps;
my %topbuild;

my @lbmodules = qw/client client-java common doc logger server state-machine types utils ws-interface/;


my @opts = (
	'prefix=s' => \$prefix,
	'staged=s' => \$staged,
	'module=s' => \$module,
	'thrflavour=s' => \$thrflavour,
	'nothrflavour=s' => \$nothrflavour,
	'mode=s' => \$mode,
	'help' => \$help,
);

for (@nodes) {
	$enable_nodes{$_} = 0;
	$disable_nodes{$_} = 0;
	
	push @opts,"disable-$_",\$disable_nodes{$_};
	push @opts,"enable-$_",\$enable_nodes{$_};
}

push @opts,"with-$_=s",\$extern_prefix{$_} for keys %extern_prefix;

my @keeparg = @ARGV;

GetOptions @opts or die "Errors parsing command line\n";

if ($help) { usage(); exit 0; }


my $en;
for (keys %enable_nodes) { $en = 1 if $enable_nodes{$_}; }

my $dis;
for (keys %disable_nodes) { $dis = 1 if $disable_nodes{$_}; }

die "--enable-* and --disable-* are mutually exclusive\n"
	if $en && $dis;

die "--module cannot be used with --enable-* or --disable-*\n"
	if $module && ($en || $dis);

die "$module: unknown module\n" if $module && ! grep $module,@lbmodules;

if ($dis) {
	for (@nodes) {
		$enable_nodes{$_} = 1 unless $disable_nodes{$_};
	}
}

if (!$en && !$dis) { $enable_nodes{$_} = 1 for (@nodes) } ;

for (keys %enable_nodes) { delete $enable_nodes{$_} unless $enable_nodes{$_}; }

print "Writing config.status\n";
open CONF,">config.status" or die "config.status: $!\n";
print CONF "$0 @keeparg\n";
close CONF;


my @modules;
my %aux;

if ($module) {
	push @modules,$module;
}
else {
	@modules = map 'lb.'.($extranodmod{$_} ? $extranodmod{$_} : $_),keys %enable_nodes;
	
	my $n;

	do {
		local $"="\n";
 		$n = $#modules;
		push @modules,(map @{$deps{$_}},@modules);

		undef %aux; @aux{@modules} = (1) x $#modules;
		@modules = keys %aux;
	} while ($#modules > $n);
}

@aux{@modules} = (1) x $#modules;
delete $aux{$_} for (split /,/,$staged);
@modules = keys %aux;

mode_build() if $mode eq 'build';
mode_checkout() if $mode eq 'checkout';

sub mode_build {
	print "\nBuilding modules: @modules\n";
	
	my @ext = map @{$need_externs{$_}},@modules;
	undef %aux; @aux{@ext} = 1;
	@ext = keys %aux;
	
	print "\nRequired externals:\n";
	print "\t$_: $extern_prefix{$_}\n" for @ext;
	print "\nThis is a poor-man configure, it's up to you to have sources and externals there\n\n";
	
	mkinc($_) for @modules;
	
	print "Creating Makefile\n";
	
	open MAK,">Makefile" or die "Makefile: $!\n";
	
	print MAK "all: @modules\n\nclean:\n";
	
	for (@modules) {
		my $full = full($_);
		my $build = $topbuild{$_} ? '': '/build';
		print MAK "\tcd $full$build && \${MAKE} clean\n"
	}
	
	print MAK "\ndistclean:\n";
	
	for (@modules) {
		my $full = full($_);
		print MAK $topbuild{$_} ?
			"\tcd $full$build && \${MAKE} distclean\n" :
			"\trm -rf $full$build\n"
	}
	
	print MAK "\n";
	
	for (@modules) {
		my %ldeps; undef %ldeps;  
		@ldeps{@{$deps{$_}}} = 1;
		for my $x (split /,/,$staged) { delete $ldeps{$x}; }
		my @dnames = keys %ldeps;
	
		my $full = full($_);
		my $build = $topbuild{$_} ? '': '/build';
	
		print MAK "$_: @dnames\n\tcd $full$build && \${MAKE} && \${MAKE} install\n\n";
	}
	
	close MAK;
}
	
sub mode_checkout() {
	for (@modules) {
		$_ = full($_);
		print "\n*** Checking out $_\n";
		system("cvs checkout $_") == 0 or die "cvs checkout $_: $?\n";
	}
}

BEGIN{
%need_externs = (
	'lb.client' => [ qw/cppunit classads/ ],
	'lb.common' => [ qw/expat cppunit classads/ ],
	'lb.doc' => [],
	'lb.logger' => [ qw/cppunit/ ],
	'lb.server' => [ qw/globus expat cares mysql cppunit gsoap classads/ ],
	'lb.state-machine' => [ qw/classads/ ],
	'lb.utils' => [ qw/cppunit/ ],
	'lb.ws-interface' => [],
	'lb.types' => [ qw// ],
	'lbjp-common.db' => [ qw/mysql/ ],
	'lbjp-common.maildir' => [ qw// ],
	'lbjp-common.server-bones' => [ qw// ],
	'lbjp-common.trio' => [ qw// ],
	'security.gss' =>  [ qw/globus cares cppunit/ ],
	'security.gsoap-plugin' =>  [ qw/cppunit globus cares gsoap/ ],
	'jobid.api-c' =>  [ qw/cppunit/ ],
	'jobid.api-cpp' =>  [ qw/cppunit/ ],
	'jobid.api-java' =>  [ qw// ],
);

%build_only = (
	'security.gsoap-plugin' => [ qw/gsoap/ ],
);

%deps = (
	'lb.client' => [ qw/
		lb.types lb.common
		lbjp-common.trio
		jobid.api-cpp jobid.api-c
		security.gss
	/ ],
	'lb.client-java' => [ qw/
		lb.types
		jobid.api-java
	/ ],
	'lb.common' => [ qw/
		jobid.api-cpp jobid.api-c
		lb.types lbjp-common.trio security.gss
	/ ],
	'lb.doc' => [ qw/lb.types/ ],
	'lb.logger' => [ qw/
		lbjp-common.trio
		jobid.api-c
		lb.common
		security.gss
	/ ],
	'lb.server' => [ qw/
		lb.ws-interface lb.logger lb.types lb.common lb.state-machine
		lbjp-common.db lbjp-common.server-bones lbjp-common.trio lbjp-common.maildir
		jobid.api-c
		security.gsoap-plugin security.lcas security.voms
		gridsite
	/ ],
	'lb.state-machine' => [ qw/lb.common jp.common security.gss/ ],
	'lb.utils' => [ qw/
		jp.common
		jobid.api-c
		lbjp-common.trio lbjp-common.maildir
		lb.client lb.state-machine
	/ ],
	'lb.ws-interface' => [ qw/lb.types/ ],
	'lb.types' => [ qw// ],
	'lbjp-common.db' => [ qw/lbjp-common.trio/ ],
	'lbjp-common.maildir' => [ qw// ],
	'lbjp-common.server-bones' => [ qw// ],
	'lbjp-common.trio' => [ qw// ],
	'security.gss' =>  [ qw// ],
	'security.gsoap-plugin' =>  [ qw/security.gss/ ],
	'jobid.api-c' =>  [ qw// ],
	'jobid.api-cpp' =>  [ qw/jobid.api-c/ ],
	'jobid.api-java' =>  [ qw// ],

	'jp.common' => [ qw/lbjp-common.db/ ],
);

%extrafull = ( gridsite=>'org.gridsite.core');

%extranodmod = ( java => 'client-java' );

my @t = qw/lb.client-java jobid.api-java lb.types/;
@topbuild{@t} = (1) x ($#t+1);
}

sub full
{
	my $short = shift;
	return $extrafull{$short} ? $extrafull{$short} : 'org.glite.'.$short;
}

sub mkinc
{
	my %aux;
	undef %aux;
	my @m=qw/
lb.client lb.doc lb.state-machine lb.ws-interface lb.logger lb.types lb.common lb.server lb.utils 
security.gss security.gsoap-plugin
jobid.api-c jobid.api-cpp
lbjp-common.db lbjp-common.maildir lbjp-common.server-bones lbjp-common.trio
jp.common/;
	@aux{@m} = (1) x ($#m+1);

	my $short = shift;
	my $full = full $short;

	unless ($aux{$short}) {
		print "Makefile.inc not needed in $full\n";
		return;
	}

	my $build = '';
	
	unless ($topbuild{$_}) {
		$build = '/build';
		unless (-d "$full/build") {
			mkdir "$full/build" or die "mkdir $full/build: $!\n";
		}
		unlink "$full/build/Makefile";
		symlink "../Makefile","$full/build/Makefile" or die "symlink ../Makefile $full/build/Makefile: $!\n";
	}

	open MKINC,">$full$build/Makefile.inc"
		or die "$full$build/Makefile.inc: $!\n";

	print "Creating $full$build/Makefile.inc\n";

	print MKINC qq{
PREFIX = $prefix
stagedir = $prefix
thrflavour = $thrflavour
nothrflavour = $nothrflavour
};

	for (@{$need_externs{$short}}) {
		print MKINC "${_}_prefix = $extern_prefix{$_}\n"
	}

	my $need_gsoap = 0;
	for (@{$need_externs{$short}})  { $need_gsoap = 1 if $_ eq 'gsoap'; }

	print MKINC "gsoap_default_version=".gsoap_version()."\n"  if $need_gsoap;

	close MKINC;
}

sub gsoap_version {
	local $_;
	my $gsoap_version;
	open S,"$extern_prefix{gsoap}/bin/soapcpp2 -v 2>&1 |" or die "$extern_prefix{gsoap}/bin/soapcpp2: $!\n";

	while ($_ = <S>) {
		chomp;

		$gsoap_version = $1 if /The gSOAP Stub and Skeleton Compiler for C and C\+\+ ([.[:digit:][:alpha:]]+)$/;
	}
	close S;
	return $gsoap_version;
}


sub usage {
	my @ext = keys %extern_prefix;

	print STDERR qq{
usage: $0 options

General options (defaults in []):
  --prefix=PREFIX		destination directory [./stage]
  --staged=module,module,...	what is already in PREFIX (specify without org.glite.)
  --thrflavour=flavour
  --nothrflavour=flavour	threaded and non-treaded flavours [gcc64dbgpthr,gcc64dbg]
  
Mode of operation:
  --mode={checkout|build}	what to do [build]
  
What to build:
  --module=module		build this module only (mostly in-Etics operation)
  --enable-NODE			build this "node" (set of modules) only. Available nodes are
					@lbmodules
  --disable-NODE		don't build this node

Dependencies:
  --with-EXTERNAL=PATH		where to look for an external. Required externals
 				(not all for all modules) are:
					@ext
				Summary of what will be used is always printed

};

}
